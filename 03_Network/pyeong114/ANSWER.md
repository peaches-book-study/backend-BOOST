# 네트워크 예상질문 리스트

1. TCP와 UDP에 대해 설명하고, TCP와 UDP의 차이에 대해 설명해주세요 ⭐️⭐️⭐️⭐️⭐️
2. TCP에서 데이터의 신뢰성을 보장하기 위한 방법은 어떤 것이 있는지 설명해주세요. ⭐️
    1. 오류제어란 ?
    2. 혼잡제어란 ?
3. 3-way handshaking과 4-way handshaking에 대해 설명해주세요. ⭐️⭐️⭐️
4. 사용자가 URL을 입력한 후 화면이 출력되기까지의 과정을 설명해주세요 ****⭐️⭐️⭐️⭐️⭐️
5. HTTP 프로토콜에 대해 설명해주세요 ⭐️⭐️⭐️
6. HTTP와 HTTPS의 차이점에 대해서 설명해주세요. ⭐️⭐️⭐️⭐️⭐️
    1. 암호화 방식
7. HTTP 1.0과 1.1의 차이에 대해 설명하세요. ⭐️⭐️⭐️
8. 쿠키(Cookie)와 세션(Session)의 차이점에 대해 설명해주세요 ⭐️⭐️
9. OSI 7 layer와 각 계층에 대해 아는대로 설명해주세요. ⭐️⭐️⭐️⭐️
10. TCP/IP 프로토콜을 스택 4계층으로 설명해주세요. ⭐️⭐️
11. HTTP에서 사용되는 Method와 각 용도에 대해서 설명해주세요. ⭐️⭐️⭐️
12. GET과 POST의 차이를 설명하세요. ⭐️⭐️⭐️⭐️
13. REST(REST API)에 대해 설명하고 RESTful이란 무엇인지 설명해주세요. ⭐️⭐️
14. 공인(public) IP와 사설(private) IP의 차이에 대해 설명해주세요. ⭐️⭐️⭐️
15. 라우팅 알고리즘에 대해서 설명해주세요
16. 라우터와 스위치의 차이에 대해 설명해주세요. ⭐️
17. 세션 기반 인증과 토큰 기반 인증의 차이에 대해 설명하고, 어느 경우에 적합한지 설명해주세요. ⭐️⭐️
18. CORS에 대해 설명해주세요.
19. 유니캐스트, 브로드캐스트, 멀티캐스트, 애니캐스트에 대해 설명해주세요.
20. JWT 토큰에 대해 설명해주세요. ⭐️
21. Connection timeout 과 Read timeout의 차이에 대해 설명해주세요. ⭐️⭐️
22. IOCP에 대해 설명해주세요.
23. POOLING은 무엇인지 설명해주세요.
24. 대칭키, 비대칭키 암호화 방식에 대해 설명해주세요. 
25. DNS란 무엇인지 설명해주세요.


---
**🔍 1. TCP와 UDP에 대해 설명하고, TCP와 UDP의 차이에 대해 설명해주세요**
<br><br>인터넷 상에서 데이터를 전송하기 위해 사용되는 프로토콜로써, 사용 목적에 따라 선택해서 사용
<br><br>
**TCP(Transmission Control Protocol)**
<br>
- **신뢰성**
<br>: 데이터가 정확하게, 순서대로, 손실 없이 도착함, 만약 데이터 패킷이 손실되거나 오류가 발생하면, TCP는 데이터 재전송을 요청
- **연결 지향적**
<br>: 통신을 시작하기 전에 먼저 연결을 설정하는 과정(Handshake 과정)을 거침. 이를 통해 양방향 통신이 확립
- **혼잡 제어 및 흐름 제어**
<br>: 네트워크 혼잡 상태나 수신자의 데이터 처리 속도에 따라 데이터 전송 속도를 조절
<br><br>
=> 웹 페이지 로딩, 이메일 전송, 파일 전송 등 신뢰성이 중요한 응용 프로그램에 주로 사용 (신뢰성과 순서가 중요한 데이터 전송에 사용)

**UDP(User Datagram Protocol)**
<br>
- **비연결 지향적**
<br>: UDP는 연결 설정 없이 데이터를 바로 전송. 이는 데이터 전송 과정을 간소화하고 지연 시간을 줄임
- **신뢰성 없음**
<br>: 데이터가 손실되거나 순서가 바뀌어 도착하더라도, UDP는 이를 복구하거나 재정렬하지 않음. 송신자는 데이터가 정확히 도착했는지 확인할 수 없다.
- **경량 프로토콜**
<br>: TCP에 비해 헤더 크기가 작고, 처리 과정이 간단. 이로 인해 오버헤드가 적다.
<br><br>
=> 실시간 스트리밍, 온라인 게임, VoIP(음성 통화) 등 실시간성이 중요하고 일부 데이터 손실이 허용되는 응용 프로그램에 사용(지연 시간 최소화와 효율성이 중요한 경우 사용)

---
**🔍 2. TCP에서 데이터의 신뢰성을 보장하기 위한 방법은 어떤 것이 있는지 설명해주세요.**
<br><br>
### 혼잡 제어 (Congestion Control)
<br>
: 네트워크 내의 패킷 혼잡을 관리하고 제어하는 메커니즘
 
> **네트워크 혼잡?**<br>
> 네트워크 내의 장비들(라우터, 스위치 등)이 수신한 데이터를 처리할 수 있는 능력을 초과할 때 발생. 혼잡 제어의 주요 목표는 네트워크의 효율성을 최대화하고, 패킷 손실률을 최소화하는 것!

**혼잡 제어 기법**
<br>
- **느린 시작 (Slow Start)** <br>전송 속도를 점진적으로 증가시켜 네트워크 혼잡을 예방.
- **혼잡 회피 (Congestion Avoidance)** <br>네트워크가 혼잡 상태에 접근하면 데이터 전송 속도의 증가를 늦추어 혼잡을 회피.
- **빠른 재전송 (Fast Retransmit)** <br> 패킷 손실이 감지되면, 타이머가 만료되기를 기다리지 않고 즉시 재전송.
- **빠른 회복 (Fast Recovery)** <br>패킷 손실 후 혼잡 윈도우 크기를 조절하여 빠르게 회복.

### 오류 제어 (Error Control)
<br>: 데이터 전송 과정에서 발생할 수 있는 오류를 감지하고 수정하는 메커니즘
<br>
: 전송 중에 데이터가 손실되거나 손상될 수 있으며, 이러한 문제를 해결하기 위해 사용.
<br>
: 데이터의 무결성과 신뢰성을 보장하는 데 중요.

**오류 제어 기법**

- **오류 감지** <br> 패리티 비트 (Parity Bit), 체크섬 (Checksum), CRC (Cyclic Redundancy Check) 등의 방법을 사용하여 데이터 전송 중에 발생할 수 있는 오류를 감지
- **자동 반복 요청 (Automatic Repeat reQuest, ARQ)**
  - **Stop-and-Wait ARQ**
  <br>: 오류가 감지되면, 송신자는 수신자로부터 오류가 없는 확인 응답(ACK)을 받을 때까지 데이터 패킷을 재전송
  - **Go-Back-N ARQ**
  <br>: 송신자는 여러 패킷을 연속으로 보낼 수 있으며, 오류가 발견된 패킷과 그 이후의 모든 패킷을 재전송
  - **Selective Repeat ARQ**
  <br>: 오류가 감지된 패킷만을 선택적으로 재전송

---
**🔍 3. 3-way handshaking과 4-way handshaking에 대해 설명해주세요.**
<br><br>
### 3-Way Handshaking
<br>
: TCP/IP 네트워크에서 연결을 시작하기 위한 프로세스로, 클라이언트와 서버 간에 신뢰성 있는 연결을 설정하고, 데이터 전송 전에 양쪽이 서로 통신할 준비가 되었음을 확인하는 데 사용됨

3-Way Handshaking 과정은 세 단계로 구성<br>
**1) SYN**
<br>: 클라이언트가 서버로 연결 요청을 하며, SYN(Synchronize Sequence Numbers) 패킷을 전송. 이 패킷에는 클라이언트가 데이터를 전송하기 시작할 때 사용할 초기 시퀀스 번호가 포함되어 있다.<br>
**2) SYN-ACK**
<br>: 서버가 클라이언트의 연결 요청을 받고, 클라이언트로 SYN-ACK(Synchronize-Acknowledgment) 패킷을 보내어 요청을 수락. 이 패킷에는 서버의 초기 시퀀스 번호와 클라이언트의 SYN 패킷에 대한 확인 응답이 포함되어 있다.<br>
**3) ACK**
<br>: 클라이언트는 서버의 SYN-ACK 패킷을 받고, ACK(Acknowledgment) 패킷을 서버로 보내 연결이 성공적으로 수립되었음을 알림.<br>

이 프로세스를 통해 양쪽 모두 데이터 전송 준비가 완료되고, TCP 연결이 성립된다.

### 4-Way Handshaking
<br>: 주로 무선 네트워크(Wi-Fi)의 보안 프로토콜에서 사용되며, TCP/IP 네트워크에서 연결을 종료하는 과정에서도 관련이 있음. 특히, Wi-Fi Protected Access(WPA)와 같은 보안 메커니즘에서 사용되며, 클라이언트와 액세스 포인트 간의 보안 키를 교환하는 데 사용됨.
<br>: TCP/IP 네트워크에서 연결 종료를 설명할 때는 주로 TCP 연결의 정상적인 종료 과정을 설명하는 데 "4-Way Handshake" 용어가 사용됨.

4-Way Handshaking 과정<br>
**1) FIN**
<br>: 연결을 종료하려는 측(일반적으로 클라이언트)이 FIN(Finish) 패킷을 전송하여 세션 종료를 시작<br>
**2) ACK**
<br> : 다른 측(서버)은 FIN 패킷을 받고, ACK 패킷을 보내어 이를 확인.<br>
**3) FIN**
<br>: 이제 서버 측에서도 연결을 종료할 준비가 되었다고 알리기 위해 자신의 FIN 패킷을 클라이언트에게 전송.<br>
**4) ACK**
<br>: 클라이언트는 서버의 FIN 패킷에 대해 ACK 패킷을 전송하여, 연결 종료 과정을 완료.

---
**🔍 4. 사용자가 URL을 입력한 후 화면이 출력되기까지의 과정을 설명해주세요** 

**1. DNS 조회**
<br>: 브라우저는 URL에 명시된 도메인 이름을 IP 주소로 변환하기 위해 DNS(Domain Name System) 조회를 수행. 이 과정은 로컬 DNS 캐시, 시스템 캐시, ISP의 DNS 서버 등을 통해 이루어 진다.<br><br>
**2. TCP 연결**
<br>: DNS 조회를 통해 얻은 IP 주소로 TCP(Transmission Control Protocol) 연결을 시작. 웹은 기본적으로 HTTP(HyperText Transfer Protocol) 또는 HTTPS(HyperText Transfer Protocol Secure)를 사용하는데, HTTPS의 경우 SSL(Secure Sockets Layer)/TLS(Transport Layer Security)를 통한 암호화된 연결도 설정.<br><br>
**3. HTTP 요청**
<br>: TCP 연결이 성공적으로 이루어지면, 브라우저는 서버에 HTTP GET 요청을 보내 웹페이지의 데이터를 요청. HTTPS를 사용할 경우, 이 단계에서 데이터는 암호화됨.<br><br>
**4. 서버 응답**
<br>: 웹 서버는 브라우저의 요청을 받고, 요청된 URL에 해당하는 리소스(HTML 문서 등)와 함께 HTTP 응답 메시지를 반환.<br><br>
**5. 컨텐츠 다운로드**
<br>: 브라우저는 서버로부터 받은 데이터를 다운로드 함.(주로 HTML 문서)<br><br>
**6. 웹페이지 렌더링**
<br>: 브라우저는 HTML 문서를 파싱(해석)하여 DOM(Document Object Model) 트리를 구축.
<br>: CSS(Cascading Style Sheets)는 파싱되어 스타일 정보를 포함한 렌더 트리를 생성하는 데 사용.
<br>: JavaScript는 HTML과 CSS 파싱 동안 또는 그 후에 실행될 수 있으며, DOM을 조작하여 페이지의 동적인 요소를 추가하거나 변경.
<br>: 브라우저는 렌더 트리를 기반으로 페이지를 화면에 그림.<br><br>
**7. 추가 리소스 로딩**
<br>: HTML 문서 내에 정의된 이미지, CSS 파일, JavaScript 파일 등의 추가 리소스가 있을 경우, 이들도 서버로부터 요청, 다운로드, 처리 과정을 거쳐 화면에 표시.

---
**🔍 5. HTTP 프로토콜에 대해 설명해주세요**

**HTTP(HyperText Transfer Protocol)**
<br>: 웹에서 데이터를 교환하기 위한 기본적인 프로토콜.
<br>: 웹 브라우저(클라이언트)와 웹 서버 간에 HTML 문서나 이미지와 같은 리소스를 전송하기 위해 사용. 
<br>: TCP/IP 프로토콜에 기반하여 동작하며, 주로 80번 포트를 사용. 
<br> +) HTTPS(HyperText Transfer Protocol Secure)는 SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security)를 사용하여 암호화된 연결을 통해 HTTP 통신을 보안적으로 강화한 버전.

- **HTTP의 주요 특징**<br>
  - **비연결성(Connectionless)**
  <br>: 클라이언트가 서버에 요청을 보내고 서버가 클라이언트에게 응답을 보낸 후 연결을 끊음. 이는 효율성을 높이지만, 연결을 재설정해야 하는 비용이 발생.<br>
  - **무상태(Stateless)**
  <br>: 서버는 클라이언트의 상태를 유지하지 않음. 각 요청은 독립적이며, 서버는 이전 요청에 대한 정보를 저장하지 않기 때문에 서버의 간소화와 확장성은 높아지지만, 모든 요청에 사용자 인증 등의 정보를 포함해야 하는 단점이 있다.
---
**🔍 6. HTTP와 HTTPS의 차이점에 대해서 설명해주세요. (암호화 방식)**
1. **보안**
- HTTP는 데이터를 평문으로 전송하기 때문에, 데이터가 도중에 가로채질 경우 정보가 노출될 위험 존재. 
- HTTPS는 SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security) 암호화 프로토콜을 사용하여 데이터를 암호화. 데이터가 도청되거나 조작되더라도, 암호화되어 있어 안전하게 보호됨.
2. **포트 번호**
   <br> HTTP: 기본적으로 80번 포트를 사용하여 통신
   <br> HTTPS: 443번 포트를 사용하여 암호화된 통신
3. **성능**
<br>: HTTP는 암호화 과정이 없기 때문에 HTTPS에 비해 상대적으로 빠를 수 있음
4. **SSL/TLS 인증서**
<br>: HTTP는 인증서가 필요 없지만, HTTPS는 SSL/TLS 인증서가 필요. 
<br>: 이 인증서는 웹 서버의 신원을 보증하며, 브라우저와 서버 간에 안전한 연결을 구축하는 데 사용된다. 인증서는 신뢰할 수 있는 인증 기관(Certificate Authority, CA)에 의해 발급.
5. **검색 엔진 최적화(SEO)의 영향**
<br> HTTPS를 사용하는 사이트는 검색 엔진에서 더 높은 순위를 받을 수 있다.

>#### 암호화 과정
>1. SSL/TLS 핸드셰이크
<br>HTTPS 연결이 시작될 때, 클라이언트(웹 브라우저)와 서버는 SSL/TLS 핸드셰이크 과정을 수행
>- 클라이언트와 서버 간의 통신 시작
<br>: 클라이언트는 서버에 사용 가능한 SSL/TLS 버전과 암호화 알고리즘 목록을 전송.
>- 서버의 인증
<br>: 서버는 자신의 `공개 키가 포함된 디지털 인증서`를 클라이언트에게 전송. 클라이언트는 해당 인증서의 유효성을 `인증 기관(CA)을 통해 검증`.
>- 대칭 키 교환
<br>: 클라이언트와 서버는 `대칭 키 암호화를 위한 공유 비밀키(세션 키)`를 안전하게 생성 및 교환.
>- 통신 준비 완료
<br>: 핸드셰이크의 마지막 단계에서, 클라이언트와 서버는 모든 후속 통신을 위해 `공유된 비밀키를 사용`하기로 합의하고, 이를 확인.
>2. 데이터 암호화
<br> : 핸드셰이크 과정에서 생성된 공유 비밀키(세션 키)는 대칭 키 암호화에 사용됨. 이 키를 사용함으로써 클라이언트와 서버 간에 전송되는 모든 데이터(요청, 응답 포함)는 암호화되어, 중간자 공격으로부터 보호된다.
<br>: 대칭 키 암호화는 비교적 빠르기 때문에, 실시간 웹 통신에 적합.
>3. 세션 종료
<br>: 통신 세션이 종료될 때, 클라이언트와 서버는 세션 키를 폐기하고 세션을 안전하게 종료.
<br>: 이후 동일한 클라이언트와 서버 간의 새로운 연결이 시작될 때는 새로운 핸드셰이크 과정을 통해 새로운 세션 키가 생성.
---
**🔍 7. HTTP 1.0과 1.1의 차이에 대해 설명하세요.** 

#### 1) 지속적 연결(Persistent Connections)
- HTTP/1.0
<br>: 기본적으로 비지속 연결을 사용. 즉, 클라이언트와 서버 간에 한 번의 요청과 응답을 처리한 후 연결을 종료. 이는 여러 리소스를 요청할 때마다 연결을 새로 생성해야 하므로, 네트워크 지연이 증가하고 효율성이 감소.
- HTTP/1.1
<br>: 기본적으로 지속적 연결을 사용. 클라이언트와 서버가 연결을 유지하고, 여러 요청과 응답을 연속적으로 처리할 수 있다. 이를 통해 네트워크 지연을 줄이고 통신의 효율성을 높일 수 있다.
#### 2) 파이프라이닝(Pipelining)
- HTTP/1.0
<br>: 지원하지 않음. 클라이언트는 이전 요청의 응답을 받은 후에야 다음 요청을 보낼 수 있다.
- HTTP/1.1
<br>: 파이프라이닝을 지원하여, 클라이언트가 여러 요청을 연속적으로 보내고, 서버가 순차적으로 응답할 수 있다. 이는 전송 대기 시간을 줄이고 네트워크 효율성을 개선함.
<br>: 또한 요청에 대한 응답을 받기 전에도 여러 요청을 연속적으로 보낼 수 있다.
#### 3) 호스트 헤더(Host Header)
- HTTP/1.0
<br>: 호스트 헤더를 필수적으로 요구하지 않음. 따라서 하나의 IP 주소에 여러 도메인이 호스팅되는 가상 호스팅이 어렵다.
- HTTP/1.1
<br>: 호스트 헤더가 필수적. 이를 통해 여러 도메인이 하나의 IP 주소에 호스팅될 수 있게 하여, 가상 호스팅이 가능.
#### 4) 캐싱 제어(Cache Control)
- HTTP/1.0
<br>: 기본적인 캐싱 메커니즘을 제공하지만, 상세한 캐싱 제어 옵션이 부족.
- HTTP/1.1
<br>: 보다 세밀한 캐싱 제어를 위한 다양한 헤더(Cache-Control 헤더 등)를 도입. 이를 통해 웹 캐싱의 효율성과 유연성이 크게 향상됨.
#### 5) 오류 메시지와 상태 코드
: HTTP/1.1는 HTTP/1.0에 비해 더 많은 HTTP 상태 코드를 도입하여, 오류 상황과 서버의 상태를 더 정확하게 전달할 수 있다.

---
**🔍 8. 쿠키(Cookie)와 세션(Session)의 차이점에 대해 설명해주세요**

쿠키와 세션은 웹사이트가 사용자 정보를 저장하고, 사용자가 웹사이트를 탐색할 때 지속적인 상태(상태 유지, stateful communication)를 관리하는 데 사용되는 기술

HTTP는 본질적으로 비연결성이고 상태를 유지하지 않는(stateless) 프로토콜이기 때문에, 쿠키와 세션은 사용자의 상태와 세션 정보를 관리하는 중요한 역할을 한다.

### 쿠키 (Cookies)
: 클라이언트(브라우저) 측에 텍스트 파일 형태로 저장되는 작은 데이터 조각으로, 웹 서버는 HTTP 응답 헤더를 통해 쿠키를 클라이언트에 전송하고, 이후 클라이언트는 같은 서버에 요청을 할 때마다 쿠키 정보를 HTTP 요청 헤더에 포함시켜 전송함
<br>: 이를 통해 서버는 사용자를 식별하고 상태 정보를 유지할 수 있다.
- 저장 위치: 사용자의 컴퓨터(브라우저)
- 만료 시점: 쿠키는 만료 날짜/시간이 설정될 수 있으며, 설정된 시점이 지나면 자동으로 삭제됨. 세션 쿠키(브라우저가 닫힐 때 삭제됨)와 영구 쿠키(특정 기간 동안 유지)로 구분됨.
- 보안: 쿠키 데이터는 클라이언트 측에 저장되므로, 사용자나 제3자에 의해 볼 수 있고, 조작될 수 있다. 따라서 민감한 정보를 쿠키에 저장하는 것은 보안상 좋지 않다.

### 세션 (Sessions)
: 서버 측에서 사용자 정보를 저장 
<br>: 사용자가 웹사이트에 접속하여 세션을 생성하면, 서버는 고유한 세션 ID를 할당하고 이 ID를 쿠키를 통해 클라이언트에게 전송.
<br>: 사용자가 서버에 요청을 할 때마다 이 세션 ID를 포함하여 보내면, 서버는 세션 ID를 통해 사용자의 상태 정보를 조회하고 관리할 수 있다.
- 저장 위치: 서버
- 만료 시점: 세션은 사용자가 로그아웃하거나 설정된 시간 동안 활동이 없을 때 만료될 수 있다. 서버 측에서 세션의 만료 시간을 관리함.
- 보안: 세션 데이터는 서버에 저장되기 때문에, 사용자나 제3자가 직접적으로 접근할 수 없어 쿠키에 비해 보안적으로 더 안전.

>  **쿠키와 세션의 주요 차이점**
>- 저장 위치: 쿠키는 클라이언트 측에, 세션은 서버 측에 저장.
>- 리소스 사용: 쿠키는 클라이언트의 리소스를 사용하며, 세션은 서버의 리소스를 사용함.
>- 보안: 세션은 쿠키에 비해 보안적으로 더 우수. 쿠키는 클라이언트에 직접 저장되기 때문에 위험에 노출될 수 있다.
>- 데이터 용량: 쿠키는 저장할 수 있는 데이터 양에 제한이 있으며, 세션은 서버의 메모리 용량에 따라 결정됨.
>- 용도: 쿠키는 사용자의 환경 설정 저장 등 비교적 덜 민감한 정보를 저장하는 데 적합하고, 세션은 로그인 상태 유지와 같이 보안이 중요한 정보를 관리하는 데 더 적합.
---
**🔍 9. OSI 7 layer와 각 계층에 대해 아는대로 설명해주세요.**


OSI(Open Systems Interconnection) 7 계층 모델은 국제표준화기구(ISO)에 의해 개발된 네트워크 통신 프로토콜 디자인의 추상적 모델이다.

이 모델은 네트워크 통신 과정을 7개의 계층으로 분리하여, 각 계층이 특정 기능을 담당하도록 구성.

이러한 계층적 구조는 프로토콜 설계와 네트워크 트러블슈팅을 용이하게 하며, 다양한 네트워크 기술과 프로토콜의 통합을 가능하게 함.

- ### 물리계층(Physical Layer)
  - 7계층 중 최하위 계층.
  - 주로 전기적, 기계적, 기능적인 특성을 이용해 데이터를 전송.
  - 데이터는 0과 1의 비트열, 즉 On, Off의 전기적 신호 상태로 이루어져 해당 계층은 단지 데이터를 전달.
  - 데이터 전달의 역할을 할 뿐이라 알고리즘, 오류제어 기능이 없음
  - 장비로는 케이블, 리피터, 허브가 있음
- ### 데이터링크 계층(Data-Link Layer)
  - 물리적인 연결을 통하여 인접한 두 장치 간의 신뢰성 있는 정보 전송을 담당(Point-To-Point 전송)
  - 안전한 정보의 전달이라는 것은 오류나 재전송하는 기능이 존재
  - MAC 주소를 통해서 통신
  - 데이터 링크 계층에서 데이터 단위는 프레임(Frame)
  - 장비로는 브리지, 스위치가 있음
- ### 네트워크 계층(Network Layer)
  - 중계 노드를 통하여 전송하는 경우 어떻게 중계할 것인가를 규정
  - 라우팅 기능을 맡고 있는 계층으로 목적지까지 가장 안전하고 빠르게 데이터를 보내는 기능을 가지고 있음(최적의 경로를 설정가능)
  - 컴퓨터에게 데이터를 전송할지 주소를 갖고 있어서 통신가능(=우리가 자주 듣는 IP 주소가 바로 네트워크 계층 헤더에 속함)
  - 네트워크 계층에서 데이터 단위는 패킷(Packet)
  - 장비로는 라우터, L3 스위치가 있음
- ### 전송 계층(Transport Layer)
  - 종단 간 신뢰성 있고 정확한 데이터 전송을 담당
  - 송신자와 수신자 간의 신뢰성있고 효율적인 데이터를 전송하기 위하여 오류검출 및 복구, 흐름제어와 중복검사 등을 수행
  - 데이터 전송을 위해서 Port 번호를 사용함.(대표적인 프로토콜로 TCP와 UDP가 있음)
  - 전송 계층에서 데이터 단위는 세그먼트(Segment)
- ### 세션 계층(Session Layer)
  - 통신 장치 간 상호작용 및 동기화를 제공
  - 연결 세션에서 데이터 교환과 에러 발생 시의 복구를 관리
- ### 표현 계층(Presentation Layer)
  - 데이터를 어떻게 표현할지 정하는 역할을 하는 계층
  - 표현 계층은 세가지의 기능을 갖고 있습니다.
  - 송신자에서 온 데이터를 해석하기 위한 응용계층 데이터 부호화, 변화
  - 수신자에서 데이터의 압축을 풀수 있는 방식으로 된 데이터 압축
  - 데이터의 암호화와 복호화
  (MIME 인코딩이나 암호화 등의 동작이 표현계층에서 이루어짐. EBCDIC로 인코딩된 파일을 ASCII 로 인코딩된 파일로 바꿔주는 것이 한가지 예임)
- ### 응용 계층(Application Layer)
  - 사용자와 가장 밀접한 계층으로 인터페이스 역할
  - 응용 프로세스 간의 정보 교환을 담당
  - ex) 전자메일, 인터넷, 동영상 플레이어 등


---
**🔍 10. TCP/IP 프로토콜을 스택 4계층으로 설명해주세요.**
### 네트워크 인터페이스 계층 (Network Interface Layer)
물리적 네트워크 하드웨어와 직접적으로 상호 작용하는 계층으로, OSI 모델의 물리 계층과 데이터 링크 계층에 해당함. 이 계층은 네트워크 미디어(케이블, 무선 등)를 통해 데이터의 프레임을 전송하고 받는 역할을 한다.
<br> ex) 이더넷(Ethernet), Wi-Fi(무선 LAN), PPP(Point-to-Point Protocol) 등.
### 인터넷 계층 (Internet Layer)
다양한 네트워크 간의 데이터 전송을 담당하며, 패킷의 라우팅과 전달을 관리. 이 계층은 데이터 패킷에 IP 주소를 부여하고, 최적의 경로를 통해 목적지까지 패킷을 전달한다.
<br> ex) IP(Internet Protocol), ICMP(Internet Control Message Protocol), ARP(Address Resolution Protocol), RIP(Routing Information Protocol) 등. 
### 전송 계층 (Transport Layer)
종단 간(End-to-End) 통신을 관리하며, 데이터의 신뢰성 있는 전송을 보장함. 이 계층은 데이터를 세그먼트로 분할하고, 목적지에서 데이터를 다시 조립하는 역할을 한다. 또한, 오류 검출, 데이터 순서 관리, 흐름 제어 및 혼잡 제어 등을 수행.
<br> ex) TCP(Transmission Control Protocol), UDP(User Datagram Protocol) 등. 
### 응용 계층 (Application Layer)
사용자와 직접적으로 상호 작용하는 소프트웨어 애플리케이션을 위한 인터페이스를 제공. 이 계층은 네트워크 서비스에 대한 접근을 관리하며, 사용자의 데이터를 네트워크에 적합한 형태로 변환한다.
<br> ex) HTTP(HyperText Transfer Protocol), FTP(File Transfer Protocol), SMTP(Simple Mail Transfer Protocol), DNS(Domain Name System) 등.

---
**🔍 11. HTTP에서 사용되는 Method와 각 용도에 대해서 설명해주세요.**
- GET
<br>: 서버에서 리소스를 요청할 때 사용. 데이터를 조회할 때 주로 사용.
- POST
<br> : 서버에 데이터를 전송할 때 사용. 데이터 생성 및 수정에 주로 사용.
- PUT
<br>: 지정된 URI에 리소스를 생성하거나 업데이트할 때 사용.
- DELETE
<br>: 지정된 URI의 리소스를 삭제할 때 사용.
- HEAD
<br>: GET 메소드와 비슷하지만, 응답 본문 없이 헤더 정보만 요청할 때 사용.
- OPTIONS
<br>: 대상 리소스에 대해 통신 가능한 HTTP 메소드를 조회할 때 사용.
- PATCH
<br>: 리소스의 부분적인 수정을 위해 사용.

---
**🔍 12. GET과 POST의 차이를 설명하세요.**

#### GET 
- 목적
<br>: 주로 서버에서 데이터를 검색하거나 요청하기 위해 사용. GET은 데이터를 가져오는 데 사용되며, 데이터를 서버에 전송할 때 URL의 일부로 데이터를 붙여 보냅니다.
- 데이터 전송 방식
<br>:요청 시 데이터가 URL에 파라미터로 붙어서 전송. 
- 용도
<br>: 검색 쿼리, 특정 페이지 요청, 시스템 상태 확인 등 읽기 전용 요청에 주로 사용.
- 제한 사항
<br>: URL 길이에는 제한이 있어, 보낼 수 있는 데이터 양에 제한이 있음. 또한, 데이터가 URL에 노출되기 때문에 민감한 정보를 전송하기에는 부적합함.
- 캐싱
<br>: GET 요청은 결과를 캐싱할 수 있기 때문에 동일한 요청에 대해 서버 부하를 줄이는 데 도움이 됨.

#### POST 
- 목적
<br>: 서버에 데이터를 제출하여 생성 또는 업데이트하기 위해 사용
- 데이터 전송 방식
<br>: 요청의 본문(body)을 통해 데이터를 전송. 이는 URL에 데이터를 붙이는 GET 방식과는 달리, 보다 많은 양의 데이터를 안전하게 전송할 수 있다.
- 용도
<br>: 리소스 생성 및 수정 요청 등에 사용.
- 제한 사항
<br>: 데이터 양에 대한 제한이 없으며, 데이터가 URL에 노출되지 않아 더 안전.
- 캐싱
<br>: POST 요청은 캐싱되지 않으며, 요청마다 서버에서 처리가 필요함.

