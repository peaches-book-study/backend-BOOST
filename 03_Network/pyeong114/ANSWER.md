# 네트워크 예상질문 리스트

1. TCP와 UDP에 대해 설명하고, TCP와 UDP의 차이에 대해 설명해주세요 ⭐️⭐️⭐️⭐️⭐️
2. TCP에서 데이터의 신뢰성을 보장하기 위한 방법은 어떤 것이 있는지 설명해주세요. ⭐️
    1. 오류제어란 ?
    2. 혼잡제어란 ?
3. 3-way handshaking과 4-way handshaking에 대해 설명해주세요. ⭐️⭐️⭐️
4. 사용자가 URL을 입력한 후 화면이 출력되기까지의 과정을 설명해주세요 ****⭐️⭐️⭐️⭐️⭐️
5. HTTP 프로토콜에 대해 설명해주세요 ⭐️⭐️⭐️
6. HTTP와 HTTPS의 차이점에 대해서 설명해주세요. ⭐️⭐️⭐️⭐️⭐️
    1. 암호화 방식
7. HTTP 1.0과 1.1의 차이에 대해 설명하세요. ⭐️⭐️⭐️
8. 쿠키(Cookie)와 세션(Session)의 차이점에 대해 설명해주세요 ⭐️⭐️
9. OSI 7 layer와 각 계층에 대해 아는대로 설명해주세요. ⭐️⭐️⭐️⭐️
10. TCP/IP 프로토콜을 스택 4계층으로 설명해주세요. ⭐️⭐️
11. HTTP에서 사용되는 Method와 각 용도에 대해서 설명해주세요. ⭐️⭐️⭐️
12. GET과 POST의 차이를 설명하세요. ⭐️⭐️⭐️⭐️
13. REST(REST API)에 대해 설명하고 RESTful이란 무엇인지 설명해주세요. ⭐️⭐️
14. 공인(public) IP와 사설(private) IP의 차이에 대해 설명해주세요. ⭐️⭐️⭐️
15. 라우팅 알고리즘에 대해서 설명해주세요
16. 라우터와 스위치의 차이에 대해 설명해주세요. ⭐️
17. 세션 기반 인증과 토큰 기반 인증의 차이에 대해 설명하고, 어느 경우에 적합한지 설명해주세요. ⭐️⭐️
18. CORS에 대해 설명해주세요.
19. 유니캐스트, 브로드캐스트, 멀티캐스트, 애니캐스트에 대해 설명해주세요.
20. JWT 토큰에 대해 설명해주세요. ⭐️
21. Connection timeout 과 Read timeout의 차이에 대해 설명해주세요. ⭐️⭐️
22. IOCP에 대해 설명해주세요.
23. POOLING은 무엇인지 설명해주세요.
24. 대칭키, 비대칭키 암호화 방식에 대해 설명해주세요. 
25. DNS란 무엇인지 설명해주세요.


---
**🔍 1. TCP와 UDP에 대해 설명하고, TCP와 UDP의 차이에 대해 설명해주세요**
<br><br>인터넷 상에서 데이터를 전송하기 위해 사용되는 프로토콜로써, 사용 목적에 따라 선택해서 사용
<br><br>
**TCP(Transmission Control Protocol)**
<br>
- **신뢰성**
<br>: 데이터가 정확하게, 순서대로, 손실 없이 도착함, 만약 데이터 패킷이 손실되거나 오류가 발생하면, TCP는 데이터 재전송을 요청
- **연결 지향적**
<br>: 통신을 시작하기 전에 먼저 연결을 설정하는 과정(Handshake 과정)을 거침. 이를 통해 양방향 통신이 확립
- **혼잡 제어 및 흐름 제어**
<br>: 네트워크 혼잡 상태나 수신자의 데이터 처리 속도에 따라 데이터 전송 속도를 조절
<br><br>
=> 웹 페이지 로딩, 이메일 전송, 파일 전송 등 신뢰성이 중요한 응용 프로그램에 주로 사용 (신뢰성과 순서가 중요한 데이터 전송에 사용)

**UDP(User Datagram Protocol)**
<br>
- **비연결 지향적**
<br>: UDP는 연결 설정 없이 데이터를 바로 전송. 이는 데이터 전송 과정을 간소화하고 지연 시간을 줄임
- **신뢰성 없음**
<br>: 데이터가 손실되거나 순서가 바뀌어 도착하더라도, UDP는 이를 복구하거나 재정렬하지 않음. 송신자는 데이터가 정확히 도착했는지 확인할 수 없다.
- **경량 프로토콜**
<br>: TCP에 비해 헤더 크기가 작고, 처리 과정이 간단. 이로 인해 오버헤드가 적다.
<br><br>
=> 실시간 스트리밍, 온라인 게임, VoIP(음성 통화) 등 실시간성이 중요하고 일부 데이터 손실이 허용되는 응용 프로그램에 사용(지연 시간 최소화와 효율성이 중요한 경우 사용)

---
**🔍 2. TCP에서 데이터의 신뢰성을 보장하기 위한 방법은 어떤 것이 있는지 설명해주세요.**
<br><br>
### 혼잡 제어 (Congestion Control)
<br>
: 네트워크 내의 패킷 혼잡을 관리하고 제어하는 메커니즘
 
> **네트워크 혼잡?**<br>
> 네트워크 내의 장비들(라우터, 스위치 등)이 수신한 데이터를 처리할 수 있는 능력을 초과할 때 발생. 혼잡 제어의 주요 목표는 네트워크의 효율성을 최대화하고, 패킷 손실률을 최소화하는 것!

**혼잡 제어 기법**
<br>
- **느린 시작 (Slow Start)** <br>전송 속도를 점진적으로 증가시켜 네트워크 혼잡을 예방.
- **혼잡 회피 (Congestion Avoidance)** <br>네트워크가 혼잡 상태에 접근하면 데이터 전송 속도의 증가를 늦추어 혼잡을 회피.
- **빠른 재전송 (Fast Retransmit)** <br> 패킷 손실이 감지되면, 타이머가 만료되기를 기다리지 않고 즉시 재전송.
- **빠른 회복 (Fast Recovery)** <br>패킷 손실 후 혼잡 윈도우 크기를 조절하여 빠르게 회복.

### 오류 제어 (Error Control)
<br>: 데이터 전송 과정에서 발생할 수 있는 오류를 감지하고 수정하는 메커니즘
<br>
: 전송 중에 데이터가 손실되거나 손상될 수 있으며, 이러한 문제를 해결하기 위해 사용.
<br>
: 데이터의 무결성과 신뢰성을 보장하는 데 중요.

**오류 제어 기법**

- **오류 감지** <br> 패리티 비트 (Parity Bit), 체크섬 (Checksum), CRC (Cyclic Redundancy Check) 등의 방법을 사용하여 데이터 전송 중에 발생할 수 있는 오류를 감지
- **자동 반복 요청 (Automatic Repeat reQuest, ARQ)**
  - **Stop-and-Wait ARQ**
  <br>: 오류가 감지되면, 송신자는 수신자로부터 오류가 없는 확인 응답(ACK)을 받을 때까지 데이터 패킷을 재전송
  - **Go-Back-N ARQ**
  <br>: 송신자는 여러 패킷을 연속으로 보낼 수 있으며, 오류가 발견된 패킷과 그 이후의 모든 패킷을 재전송
  - **Selective Repeat ARQ**
  <br>: 오류가 감지된 패킷만을 선택적으로 재전송

---
**🔍 3. 3-way handshaking과 4-way handshaking에 대해 설명해주세요.**
<br><br>
### 3-Way Handshaking
<br>
: TCP/IP 네트워크에서 연결을 시작하기 위한 프로세스로, 클라이언트와 서버 간에 신뢰성 있는 연결을 설정하고, 데이터 전송 전에 양쪽이 서로 통신할 준비가 되었음을 확인하는 데 사용됨

3-Way Handshaking 과정은 세 단계로 구성<br>
**1) SYN**
<br>: 클라이언트가 서버로 연결 요청을 하며, SYN(Synchronize Sequence Numbers) 패킷을 전송. 이 패킷에는 클라이언트가 데이터를 전송하기 시작할 때 사용할 초기 시퀀스 번호가 포함되어 있다.<br>
**2) SYN-ACK**
<br>: 서버가 클라이언트의 연결 요청을 받고, 클라이언트로 SYN-ACK(Synchronize-Acknowledgment) 패킷을 보내어 요청을 수락. 이 패킷에는 서버의 초기 시퀀스 번호와 클라이언트의 SYN 패킷에 대한 확인 응답이 포함되어 있다.<br>
**3) ACK**
<br>: 클라이언트는 서버의 SYN-ACK 패킷을 받고, ACK(Acknowledgment) 패킷을 서버로 보내 연결이 성공적으로 수립되었음을 알림.<br>

이 프로세스를 통해 양쪽 모두 데이터 전송 준비가 완료되고, TCP 연결이 성립된다.

### 4-Way Handshaking
<br>: 주로 무선 네트워크(Wi-Fi)의 보안 프로토콜에서 사용되며, TCP/IP 네트워크에서 연결을 종료하는 과정에서도 관련이 있음. 특히, Wi-Fi Protected Access(WPA)와 같은 보안 메커니즘에서 사용되며, 클라이언트와 액세스 포인트 간의 보안 키를 교환하는 데 사용됨.
<br>: TCP/IP 네트워크에서 연결 종료를 설명할 때는 주로 TCP 연결의 정상적인 종료 과정을 설명하는 데 "4-Way Handshake" 용어가 사용됨.

4-Way Handshaking 과정<br>
**1) FIN**
<br>: 연결을 종료하려는 측(일반적으로 클라이언트)이 FIN(Finish) 패킷을 전송하여 세션 종료를 시작<br>
**2) ACK**
<br> : 다른 측(서버)은 FIN 패킷을 받고, ACK 패킷을 보내어 이를 확인.<br>
**3) FIN**
<br>: 이제 서버 측에서도 연결을 종료할 준비가 되었다고 알리기 위해 자신의 FIN 패킷을 클라이언트에게 전송.<br>
**4) ACK**
<br>: 클라이언트는 서버의 FIN 패킷에 대해 ACK 패킷을 전송하여, 연결 종료 과정을 완료.

---
**🔍 4. 사용자가 URL을 입력한 후 화면이 출력되기까지의 과정을 설명해주세요** 

**1. DNS 조회**
<br>: 브라우저는 URL에 명시된 도메인 이름을 IP 주소로 변환하기 위해 DNS(Domain Name System) 조회를 수행. 이 과정은 로컬 DNS 캐시, 시스템 캐시, ISP의 DNS 서버 등을 통해 이루어 진다.<br><br>
**2. TCP 연결**
<br>: DNS 조회를 통해 얻은 IP 주소로 TCP(Transmission Control Protocol) 연결을 시작. 웹은 기본적으로 HTTP(HyperText Transfer Protocol) 또는 HTTPS(HyperText Transfer Protocol Secure)를 사용하는데, HTTPS의 경우 SSL(Secure Sockets Layer)/TLS(Transport Layer Security)를 통한 암호화된 연결도 설정.<br><br>
**3. HTTP 요청**
<br>: TCP 연결이 성공적으로 이루어지면, 브라우저는 서버에 HTTP GET 요청을 보내 웹페이지의 데이터를 요청. HTTPS를 사용할 경우, 이 단계에서 데이터는 암호화됨.<br><br>
**4. 서버 응답**
<br>: 웹 서버는 브라우저의 요청을 받고, 요청된 URL에 해당하는 리소스(HTML 문서 등)와 함께 HTTP 응답 메시지를 반환.<br><br>
**5. 컨텐츠 다운로드**
<br>: 브라우저는 서버로부터 받은 데이터를 다운로드 함.(주로 HTML 문서)<br><br>
**6. 웹페이지 렌더링**
<br>: 브라우저는 HTML 문서를 파싱(해석)하여 DOM(Document Object Model) 트리를 구축.
<br>: CSS(Cascading Style Sheets)는 파싱되어 스타일 정보를 포함한 렌더 트리를 생성하는 데 사용.
<br>: JavaScript는 HTML과 CSS 파싱 동안 또는 그 후에 실행될 수 있으며, DOM을 조작하여 페이지의 동적인 요소를 추가하거나 변경.
<br>: 브라우저는 렌더 트리를 기반으로 페이지를 화면에 그림.<br><br>
**7. 추가 리소스 로딩**
<br>: HTML 문서 내에 정의된 이미지, CSS 파일, JavaScript 파일 등의 추가 리소스가 있을 경우, 이들도 서버로부터 요청, 다운로드, 처리 과정을 거쳐 화면에 표시.

---
**🔍 5. HTTP 프로토콜에 대해 설명해주세요**

**HTTP(HyperText Transfer Protocol)**
<br>: 웹에서 데이터를 교환하기 위한 기본적인 프로토콜.
<br>: 웹 브라우저(클라이언트)와 웹 서버 간에 HTML 문서나 이미지와 같은 리소스를 전송하기 위해 사용. 
<br>: TCP/IP 프로토콜에 기반하여 동작하며, 주로 80번 포트를 사용. 
<br> +) HTTPS(HyperText Transfer Protocol Secure)는 SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security)를 사용하여 암호화된 연결을 통해 HTTP 통신을 보안적으로 강화한 버전.

- **HTTP의 주요 특징**<br>
  - **비연결성(Connectionless)**
  <br>: 클라이언트가 서버에 요청을 보내고 서버가 클라이언트에게 응답을 보낸 후 연결을 끊음. 이는 효율성을 높이지만, 연결을 재설정해야 하는 비용이 발생.<br>
  - **무상태(Stateless)**
  <br>: 서버는 클라이언트의 상태를 유지하지 않음. 각 요청은 독립적이며, 서버는 이전 요청에 대한 정보를 저장하지 않기 때문에 서버의 간소화와 확장성은 높아지지만, 모든 요청에 사용자 인증 등의 정보를 포함해야 하는 단점이 있다.
---
**🔍 6. HTTP와 HTTPS의 차이점에 대해서 설명해주세요. (암호화 방식)**
1. **보안**
- HTTP는 데이터를 평문으로 전송하기 때문에, 데이터가 도중에 가로채질 경우 정보가 노출될 위험 존재. 
- HTTPS는 SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security) 암호화 프로토콜을 사용하여 데이터를 암호화. 데이터가 도청되거나 조작되더라도, 암호화되어 있어 안전하게 보호됨.
2. **포트 번호**
   <br> HTTP: 기본적으로 80번 포트를 사용하여 통신
   <br> HTTPS: 443번 포트를 사용하여 암호화된 통신
3. **성능**
<br>: HTTP는 암호화 과정이 없기 때문에 HTTPS에 비해 상대적으로 빠를 수 있음
4. **SSL/TLS 인증서**
<br>: HTTP는 인증서가 필요 없지만, HTTPS는 SSL/TLS 인증서가 필요. 
<br>: 이 인증서는 웹 서버의 신원을 보증하며, 브라우저와 서버 간에 안전한 연결을 구축하는 데 사용된다. 인증서는 신뢰할 수 있는 인증 기관(Certificate Authority, CA)에 의해 발급.
5. **검색 엔진 최적화(SEO)의 영향**
<br> HTTPS를 사용하는 사이트는 검색 엔진에서 더 높은 순위를 받을 수 있다.

>#### 암호화 과정
>1. SSL/TLS 핸드셰이크
<br>HTTPS 연결이 시작될 때, 클라이언트(웹 브라우저)와 서버는 SSL/TLS 핸드셰이크 과정을 수행
>- 클라이언트와 서버 간의 통신 시작
<br>: 클라이언트는 서버에 사용 가능한 SSL/TLS 버전과 암호화 알고리즘 목록을 전송.
>- 서버의 인증
<br>: 서버는 자신의 `공개 키가 포함된 디지털 인증서`를 클라이언트에게 전송. 클라이언트는 해당 인증서의 유효성을 `인증 기관(CA)을 통해 검증`.
>- 대칭 키 교환
<br>: 클라이언트와 서버는 `대칭 키 암호화를 위한 공유 비밀키(세션 키)`를 안전하게 생성 및 교환.
>- 통신 준비 완료
<br>: 핸드셰이크의 마지막 단계에서, 클라이언트와 서버는 모든 후속 통신을 위해 `공유된 비밀키를 사용`하기로 합의하고, 이를 확인.
>2. 데이터 암호화
<br> : 핸드셰이크 과정에서 생성된 공유 비밀키(세션 키)는 대칭 키 암호화에 사용됨. 이 키를 사용함으로써 클라이언트와 서버 간에 전송되는 모든 데이터(요청, 응답 포함)는 암호화되어, 중간자 공격으로부터 보호된다.
<br>: 대칭 키 암호화는 비교적 빠르기 때문에, 실시간 웹 통신에 적합.
>3. 세션 종료
<br>: 통신 세션이 종료될 때, 클라이언트와 서버는 세션 키를 폐기하고 세션을 안전하게 종료.
<br>: 이후 동일한 클라이언트와 서버 간의 새로운 연결이 시작될 때는 새로운 핸드셰이크 과정을 통해 새로운 세션 키가 생성.
---
**🔍 7. HTTP 1.0과 1.1의 차이에 대해 설명하세요.** 

#### 1) 지속적 연결(Persistent Connections)
- HTTP/1.0
<br>: 기본적으로 비지속 연결을 사용. 즉, 클라이언트와 서버 간에 한 번의 요청과 응답을 처리한 후 연결을 종료. 이는 여러 리소스를 요청할 때마다 연결을 새로 생성해야 하므로, 네트워크 지연이 증가하고 효율성이 감소.
- HTTP/1.1
<br>: 기본적으로 지속적 연결을 사용. 클라이언트와 서버가 연결을 유지하고, 여러 요청과 응답을 연속적으로 처리할 수 있다. 이를 통해 네트워크 지연을 줄이고 통신의 효율성을 높일 수 있다.
#### 2) 파이프라이닝(Pipelining)
- HTTP/1.0
<br>: 지원하지 않음. 클라이언트는 이전 요청의 응답을 받은 후에야 다음 요청을 보낼 수 있다.
- HTTP/1.1
<br>: 파이프라이닝을 지원하여, 클라이언트가 여러 요청을 연속적으로 보내고, 서버가 순차적으로 응답할 수 있다. 이는 전송 대기 시간을 줄이고 네트워크 효율성을 개선함.
<br>: 또한 요청에 대한 응답을 받기 전에도 여러 요청을 연속적으로 보낼 수 있다.
#### 3) 호스트 헤더(Host Header)
- HTTP/1.0
<br>: 호스트 헤더를 필수적으로 요구하지 않음. 따라서 하나의 IP 주소에 여러 도메인이 호스팅되는 가상 호스팅이 어렵다.
- HTTP/1.1
<br>: 호스트 헤더가 필수적. 이를 통해 여러 도메인이 하나의 IP 주소에 호스팅될 수 있게 하여, 가상 호스팅이 가능.
#### 4) 캐싱 제어(Cache Control)
- HTTP/1.0
<br>: 기본적인 캐싱 메커니즘을 제공하지만, 상세한 캐싱 제어 옵션이 부족.
- HTTP/1.1
<br>: 보다 세밀한 캐싱 제어를 위한 다양한 헤더(Cache-Control 헤더 등)를 도입. 이를 통해 웹 캐싱의 효율성과 유연성이 크게 향상됨.
#### 5) 오류 메시지와 상태 코드
: HTTP/1.1는 HTTP/1.0에 비해 더 많은 HTTP 상태 코드를 도입하여, 오류 상황과 서버의 상태를 더 정확하게 전달할 수 있다.

---
**🔍 8. 쿠키(Cookie)와 세션(Session)의 차이점에 대해 설명해주세요**

쿠키와 세션은 웹사이트가 사용자 정보를 저장하고, 사용자가 웹사이트를 탐색할 때 지속적인 상태(상태 유지, stateful communication)를 관리하는 데 사용되는 기술

HTTP는 본질적으로 비연결성이고 상태를 유지하지 않는(stateless) 프로토콜이기 때문에, 쿠키와 세션은 사용자의 상태와 세션 정보를 관리하는 중요한 역할을 한다.

### 쿠키 (Cookies)
: 클라이언트(브라우저) 측에 텍스트 파일 형태로 저장되는 작은 데이터 조각으로, 웹 서버는 HTTP 응답 헤더를 통해 쿠키를 클라이언트에 전송하고, 이후 클라이언트는 같은 서버에 요청을 할 때마다 쿠키 정보를 HTTP 요청 헤더에 포함시켜 전송함
<br>: 이를 통해 서버는 사용자를 식별하고 상태 정보를 유지할 수 있다.
- 저장 위치: 사용자의 컴퓨터(브라우저)
- 만료 시점: 쿠키는 만료 날짜/시간이 설정될 수 있으며, 설정된 시점이 지나면 자동으로 삭제됨. 세션 쿠키(브라우저가 닫힐 때 삭제됨)와 영구 쿠키(특정 기간 동안 유지)로 구분됨.
- 보안: 쿠키 데이터는 클라이언트 측에 저장되므로, 사용자나 제3자에 의해 볼 수 있고, 조작될 수 있다. 따라서 민감한 정보를 쿠키에 저장하는 것은 보안상 좋지 않다.

### 세션 (Sessions)
: 서버 측에서 사용자 정보를 저장 
<br>: 사용자가 웹사이트에 접속하여 세션을 생성하면, 서버는 고유한 세션 ID를 할당하고 이 ID를 쿠키를 통해 클라이언트에게 전송.
<br>: 사용자가 서버에 요청을 할 때마다 이 세션 ID를 포함하여 보내면, 서버는 세션 ID를 통해 사용자의 상태 정보를 조회하고 관리할 수 있다.
- 저장 위치: 서버
- 만료 시점: 세션은 사용자가 로그아웃하거나 설정된 시간 동안 활동이 없을 때 만료될 수 있다. 서버 측에서 세션의 만료 시간을 관리함.
- 보안: 세션 데이터는 서버에 저장되기 때문에, 사용자나 제3자가 직접적으로 접근할 수 없어 쿠키에 비해 보안적으로 더 안전.

>  **쿠키와 세션의 주요 차이점**
>- 저장 위치: 쿠키는 클라이언트 측에, 세션은 서버 측에 저장.
>- 리소스 사용: 쿠키는 클라이언트의 리소스를 사용하며, 세션은 서버의 리소스를 사용함.
>- 보안: 세션은 쿠키에 비해 보안적으로 더 우수. 쿠키는 클라이언트에 직접 저장되기 때문에 위험에 노출될 수 있다.
>- 데이터 용량: 쿠키는 저장할 수 있는 데이터 양에 제한이 있으며, 세션은 서버의 메모리 용량에 따라 결정됨.
>- 용도: 쿠키는 사용자의 환경 설정 저장 등 비교적 덜 민감한 정보를 저장하는 데 적합하고, 세션은 로그인 상태 유지와 같이 보안이 중요한 정보를 관리하는 데 더 적합.
---
**🔍 9. OSI 7 layer와 각 계층에 대해 아는대로 설명해주세요.**


OSI(Open Systems Interconnection) 7 계층 모델은 국제표준화기구(ISO)에 의해 개발된 네트워크 통신 프로토콜 디자인의 추상적 모델이다.

이 모델은 네트워크 통신 과정을 7개의 계층으로 분리하여, 각 계층이 특정 기능을 담당하도록 구성.

이러한 계층적 구조는 프로토콜 설계와 네트워크 트러블슈팅을 용이하게 하며, 다양한 네트워크 기술과 프로토콜의 통합을 가능하게 함.

- ### 물리계층(Physical Layer)
  - 7계층 중 최하위 계층.
  - 주로 전기적, 기계적, 기능적인 특성을 이용해 데이터를 전송.
  - 데이터는 0과 1의 비트열, 즉 On, Off의 전기적 신호 상태로 이루어져 해당 계층은 단지 데이터를 전달.
  - 데이터 전달의 역할을 할 뿐이라 알고리즘, 오류제어 기능이 없음
  - 장비로는 케이블, 리피터, 허브가 있음
- ### 데이터링크 계층(Data-Link Layer)
  - 물리적인 연결을 통하여 인접한 두 장치 간의 신뢰성 있는 정보 전송을 담당(Point-To-Point 전송)
  - 안전한 정보의 전달이라는 것은 오류나 재전송하는 기능이 존재
  - MAC 주소를 통해서 통신
  - 데이터 링크 계층에서 데이터 단위는 프레임(Frame)
  - 장비로는 브리지, 스위치가 있음
- ### 네트워크 계층(Network Layer)
  - 중계 노드를 통하여 전송하는 경우 어떻게 중계할 것인가를 규정
  - 라우팅 기능을 맡고 있는 계층으로 목적지까지 가장 안전하고 빠르게 데이터를 보내는 기능을 가지고 있음(최적의 경로를 설정가능)
  - 컴퓨터에게 데이터를 전송할지 주소를 갖고 있어서 통신가능(=우리가 자주 듣는 IP 주소가 바로 네트워크 계층 헤더에 속함)
  - 네트워크 계층에서 데이터 단위는 패킷(Packet)
  - 장비로는 라우터, L3 스위치가 있음
- ### 전송 계층(Transport Layer)
  - 종단 간 신뢰성 있고 정확한 데이터 전송을 담당
  - 송신자와 수신자 간의 신뢰성있고 효율적인 데이터를 전송하기 위하여 오류검출 및 복구, 흐름제어와 중복검사 등을 수행
  - 데이터 전송을 위해서 Port 번호를 사용함.(대표적인 프로토콜로 TCP와 UDP가 있음)
  - 전송 계층에서 데이터 단위는 세그먼트(Segment)
- ### 세션 계층(Session Layer)
  - 통신 장치 간 상호작용 및 동기화를 제공
  - 연결 세션에서 데이터 교환과 에러 발생 시의 복구를 관리
- ### 표현 계층(Presentation Layer)
  - 데이터를 어떻게 표현할지 정하는 역할을 하는 계층
  - 표현 계층은 세가지의 기능을 갖고 있습니다.
  - 송신자에서 온 데이터를 해석하기 위한 응용계층 데이터 부호화, 변화
  - 수신자에서 데이터의 압축을 풀수 있는 방식으로 된 데이터 압축
  - 데이터의 암호화와 복호화
  (MIME 인코딩이나 암호화 등의 동작이 표현계층에서 이루어짐. EBCDIC로 인코딩된 파일을 ASCII 로 인코딩된 파일로 바꿔주는 것이 한가지 예임)
- ### 응용 계층(Application Layer)
  - 사용자와 가장 밀접한 계층으로 인터페이스 역할
  - 응용 프로세스 간의 정보 교환을 담당
  - ex) 전자메일, 인터넷, 동영상 플레이어 등


---
**🔍 10. TCP/IP 프로토콜을 스택 4계층으로 설명해주세요.**
### 네트워크 인터페이스 계층 (Network Interface Layer)
물리적 네트워크 하드웨어와 직접적으로 상호 작용하는 계층으로, OSI 모델의 물리 계층과 데이터 링크 계층에 해당함. 이 계층은 네트워크 미디어(케이블, 무선 등)를 통해 데이터의 프레임을 전송하고 받는 역할을 한다.
<br> ex) 이더넷(Ethernet), Wi-Fi(무선 LAN), PPP(Point-to-Point Protocol) 등.
### 인터넷 계층 (Internet Layer)
다양한 네트워크 간의 데이터 전송을 담당하며, 패킷의 라우팅과 전달을 관리. 이 계층은 데이터 패킷에 IP 주소를 부여하고, 최적의 경로를 통해 목적지까지 패킷을 전달한다.
<br> ex) IP(Internet Protocol), ICMP(Internet Control Message Protocol), ARP(Address Resolution Protocol), RIP(Routing Information Protocol) 등. 
### 전송 계층 (Transport Layer)
종단 간(End-to-End) 통신을 관리하며, 데이터의 신뢰성 있는 전송을 보장함. 이 계층은 데이터를 세그먼트로 분할하고, 목적지에서 데이터를 다시 조립하는 역할을 한다. 또한, 오류 검출, 데이터 순서 관리, 흐름 제어 및 혼잡 제어 등을 수행.
<br> ex) TCP(Transmission Control Protocol), UDP(User Datagram Protocol) 등. 
### 응용 계층 (Application Layer)
사용자와 직접적으로 상호 작용하는 소프트웨어 애플리케이션을 위한 인터페이스를 제공. 이 계층은 네트워크 서비스에 대한 접근을 관리하며, 사용자의 데이터를 네트워크에 적합한 형태로 변환한다.
<br> ex) HTTP(HyperText Transfer Protocol), FTP(File Transfer Protocol), SMTP(Simple Mail Transfer Protocol), DNS(Domain Name System) 등.

---
**🔍 11. HTTP에서 사용되는 Method와 각 용도에 대해서 설명해주세요.**
- GET
<br>: 서버에서 리소스를 요청할 때 사용. 데이터를 조회할 때 주로 사용.
- POST
<br> : 서버에 데이터를 전송할 때 사용. 데이터 생성 및 수정에 주로 사용.
- PUT
<br>: 지정된 URI에 리소스를 생성하거나 업데이트할 때 사용.
- DELETE
<br>: 지정된 URI의 리소스를 삭제할 때 사용.
- HEAD
<br>: GET 메소드와 비슷하지만, 응답 본문 없이 헤더 정보만 요청할 때 사용.
- OPTIONS
<br>: 대상 리소스에 대해 통신 가능한 HTTP 메소드를 조회할 때 사용.
- PATCH
<br>: 리소스의 부분적인 수정을 위해 사용.

---
**🔍 12. GET과 POST의 차이를 설명하세요.**

#### GET 
- 목적
<br>: 주로 서버에서 데이터를 검색하거나 요청하기 위해 사용. GET은 데이터를 가져오는 데 사용되며, 데이터를 서버에 전송할 때 URL의 일부로 데이터를 붙여 보냅니다.
- 데이터 전송 방식
<br>:요청 시 데이터가 URL에 파라미터로 붙어서 전송. 
- 용도
<br>: 검색 쿼리, 특정 페이지 요청, 시스템 상태 확인 등 읽기 전용 요청에 주로 사용.
- 제한 사항
<br>: URL 길이에는 제한이 있어, 보낼 수 있는 데이터 양에 제한이 있음. 또한, 데이터가 URL에 노출되기 때문에 민감한 정보를 전송하기에는 부적합함.
- 캐싱
<br>: GET 요청은 결과를 캐싱할 수 있기 때문에 동일한 요청에 대해 서버 부하를 줄이는 데 도움이 됨.

#### POST 
- 목적
<br>: 서버에 데이터를 제출하여 생성 또는 업데이트하기 위해 사용
- 데이터 전송 방식
<br>: 요청의 본문(body)을 통해 데이터를 전송. 이는 URL에 데이터를 붙이는 GET 방식과는 달리, 보다 많은 양의 데이터를 안전하게 전송할 수 있다.
- 용도
<br>: 리소스 생성 및 수정 요청 등에 사용.
- 제한 사항
<br>: 데이터 양에 대한 제한이 없으며, 데이터가 URL에 노출되지 않아 더 안전.
- 캐싱
<br>: POST 요청은 캐싱되지 않으며, 요청마다 서버에서 처리가 필요함.

---
**🔍 13. REST(REST API)에 대해 설명하고 RESTful이란 무엇인지 설명해주세요.**

### REST
“Representational State Transfer” 의 약자로, 자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미한다.

### RESTful
REST 아키텍처 원칙을 준수하는 웹 서비스<br>
리소스 기반의 아키텍처를 사용하여 클라이언트와 서버 간의 상호작용을 설계<br>
서비스는 HTTP 프로토콜의 표준을 사용하여 리소스의 상태를 생성, 읽기, 업데이트, 삭제(CRUD 작업)하는 인터페이스를 제공

1) 간단하고 직관적인 URL 
<br> : 리소스를 식별하기 위해 명확하고 이해하기 쉬운 URI를 사용
2) 무상태(Stateless) 통신
<br> : 각 HTTP 요청은 독립적이며, 서버는 클라이언트의 상태를 유지하지 않는다.
3) 캐시 가능한 응답
<br> : 효율성을 높이기 위해 응답은 캐시될 수 있다.
4) 계층화된 시스템
<br> : 클라이언트는 보통 중간 서버를 통해 리소스에 접근할 수 있으며, 이는 네트워크의 구조를 유연하게 함.

---
**🔍 14. 공인(public) IP와 사설(private) IP의 차이에 대해 설명해주세요.️**

### IP?
컴퓨터나 네트워크 장비가 인터넷 상에서 서로를 식별하고 통신하기 위해 사용하는 숫자로 구성된 주소<br>
이 둘은 사용 목적과 범위에 따라 구분됨

### 공인(Public) IP 주소
- 정의: 인터넷 상에서 유일무이한 주소로써, 전 세계적으로 중복되지 않아야 하며, 인터넷에 직접 연결된 모든 장치는 고유한 공인 IP 주소를 가지고 있어야 한다.
- 목적: 인터넷 상에서 서로 다른 네트워크에 있는 장치들이 서로를 식별하고 통신할 수 있도록 하는 것.
- 할당: ISP(Internet Service Provider, 인터넷 서비스 제공업체)가 고객에게 공인 IP 주소를 할당함. 공인 IP 주소는 일반적으로 유동적(동적으로 변할 수 있음)이거나 고정적(정적, 변하지 않음)일 수 있습니다.
- 접근성: 공인 IP 주소는 인터넷 상의 어디서나 접근할 수 있으므로, 외부에서 접속하는 서비스를 제공하거나 원격 접속이 필요할 때 사용됨.

### 사설(Private) IP 주소
- 정의: 특정 네트워크 내에서만 유일하며, 해당 네트워크 외부에서는 중복될 수 있다. 이 주소는 인터넷 전체와는 독립적으로 사용된다.
- 목적: 일반적으로 하나의 네트워크 내에서 장치들이 서로 통신하는 데 사용된다. 이를 통해 내부 네트워크 트래픽이 구성되며, 인터넷을 사용하지 않고도 장치 간에 데이터를 주고받을 수 있다.
- 할당: 사설 IP 주소는 네트워크 관리자에 의해 수동으로 할당되거나 DHCP(Dynamic Host Configuration Protocol) 서버를 통해 자동으로 할당.
- 접근성: 사설 IP 주소는 해당 네트워크 내부에서만 접근 가능하며, 인터넷을 통해 직접 접근할 수 없다. 인터넷에 접속하기 위해서는 NAT(Network Address Translation) 같은 메커니즘을 통해 공인 IP 주소로 변환되어야 한다.

---

**🔍 15. 라우팅 알고리즘에 대해서 설명해주세요**

라우팅 알고리즘은 네트워크 내에서 데이터 패킷이 송신지에서 목적지까지 전달되는 최적의 경로를 결정하는 데 사용되는 기술. 이러한 알고리즘은 데이터 네트워크의 효율성과 성능을 향상시키는 데 중요한 역할을 함.

1. 정적 라우팅(Static Routing)<br>
   - 정의: 네트워크 관리자가 수동으로 라우팅 테이블을 설정하는 방식. 이 경로는 네트워크 변경 사항이 발생해도 자동으로 조정되지 않는다.
   - 장점: 단순하며, 작은 네트워크에서는 효율적.
   - 단점: 네트워크 변경에 유연하게 대응할 수 없고, 큰 네트워크에서는 관리가 어려움.
2. 동적 라우팅(Dynamic Routing)<br>
   - 정의: 네트워크 상태의 변화를 자동으로 감지하고 라우팅 테이블을 동적으로 조정함. 여러 라우팅 프로토콜이 이 범주에 속함.
   - 장점: 네트워크 변경에 유연하게 대응하고, 관리가 수월.
   - 단점: 정적 라우팅에 비해 더 복잡하고, 네트워크 자원을 더 많이 사용할 수 있다.
3. 거리 벡터 라우팅(Distance Vector Routing)<br>
   - 예: RIP(Routing Information Protocol)
   - 작동 방식: 각 라우터는 이웃 라우터와 자신의 라우팅 테이블을 주기적으로 교환함. 경로 비용(거리)을 기반으로 최적의 경로를 결정.
   - 특징: 구현이 단순하지만, 루프 문제와 느린 수렴 속도를 가질 수 있다.
4. 링크 상태 라우팅(Link State Routing)<br>
   - 예: OSPF(Open Shortest Path First), IS-IS
   - 작동 방식: 각 라우터가 네트워크의 전체 구조를 이해하고, 자신의 데이터베이스를 기반으로 독립적으로 최적의 경로를 계산.
   - 특징: 더 빠른 수렴과 높은 확장성을 제공하지만, 구현이 복잡하고 더 많은 메모리와 처리 능력을 요구.
5. 하이브리드 라우팅(Hybrid Routing)<br>
   - 예: EIGRP(Enhanced Interior Gateway Routing Protocol)
   - 작동 방식: 거리 벡터와 링크 상태 라우팅의 특징을 결합. 라우터는 근접한 이웃과 정보를 교환하며, 동시에 네트워크의 전체 구조를 부분적으로 이해함.
   - 특징: 빠른 수렴 속도와 높은 확장성을 제공하며, 라우팅 결정에 더 많은 정보를 사용할 수 있다.

---
**🔍 16. 라우터와 스위치의 차이에 대해 설명해주세요.️**

라우터와 스위치는 네트워크 내에서 데이터를 전송하는 데 사용되는 중요한 장비이다.<br>
이들은 데이터 `패킷의 전송 방식`과 `작동 계층`에서 주요 차이점이 존재.

### 라우터
- 작동 계층: OSI 모델의 네트워크 계층(계층 3)에서 작동.
- 기능: 다른 네트워크 간의 경로를 결정하고, 데이터 패킷을 해당 경로를 통해 전송하는 장비. 라우터는 IP 주소를 사용하여 최적의 경로를 결정하고, 데이터 패킷을 목적지 네트워크로 전달함.
- 목적: 주로 네트워크 간 연결을 제공하며, 다른 네트워크 또는 인터넷에 접속하기 위해 사용됨.
- 기타 기능: NAT(Network Address Translation), 방화벽 기능, VPN 연결 등 네트워크 보안 및 관리 기능을 제공할 수 있다.

### 스위치(Switch)
- 작동 계층: OSI 모델의 데이터 링크 계층(계층 2)에서 작동하며, 일부 고급 스위치는 네트워크 계층에서도 작동할 수 있다.
- 기능: 하나의 네트워크 내에서 장치들 간의 데이터 전송을 촉진하는 장비. 스위치는 MAC(Media Access Control) 주소를 사용하여 데이터 패킷을 올바른 목적지 장치로 전송함.
- 목적: 주로 네트워크 내 장치들 사이의 효율적인 통신을 제공하며, 네트워크의 트래픽 흐름을 관리함.
- 기타 기능: VLAN(Virtual Local Area Network) 설정을 통해 네트워크 내에서 논리적인 분리를 할 수 있으며, 효율적인 데이터 흐름 관리를 도와준다.

### 차이점
- 작동 계층: 라우터는 네트워크 계층에서, 스위치는 데이터 링크 계층에서 작동.
- 데이터 전달 방식: 라우터는 IP 주소를, 스위치는 MAC 주소를 사용하여 데이터를 전달.
- 사용 목적: 라우터는 네트워크 간 연결을 제공하는 반면, 스위치는 네트워크 내 장치들 간의 통신을 촉진.
- 보안 및 관리 기능: 라우터는 보안 및 인터넷 연결과 관련된 추가 기능을 제공하는 반면, 스위치는 주로 네트워크의 효율성과 세분화에 중점.

---
**🔍 17. 세션 기반 인증과 토큰 기반 인증의 차이에 대해 설명하고, 어느 경우에 적합한지 설명해주세요.**
### 세션 기반 인증
사용자가 로그인할 때 서버가 사용자의 인증 정보를 확인하고, 해당 세션 정보를 서버에 저장.<br>
서버는 사용자에게 세션 ID를 부여하고, 사용자는 이후의 요청에 이 세션 ID를 포함시켜 서버에 전송.<br>
서버는 세션 ID를 통해 사용자를 식별하고, 해당 사용자의 인증 상태와 권한을 확인한다.

- 장점
<br>: 구현이 비교적 단순하고 직관적.
<br>: 세션 정보가 서버에 저장되므로, 사용자의 인증 상태를 쉽게 관리할 수 있다.
- 단점
<br>: 서버 기반의 인증 방식이므로, 대규모 분산 시스템에서 세션 정보를 관리하는 것이 어렵다.
<br>: 확장성에 제한이 있으며, 서버에 부하를 줄 수 있다.

- 적합한 사용 사례
<br>: 작은 규모의 웹 애플리케이션 또는 서버 부하가 크지 않고, 서버 측에서 사용자의 상태를 세밀하게 관리해야 하는 경우에 적합.

### 토큰 기반 인증
토큰 기반 인증에서는 사용자가 로그인할 때 서버가 사용자의 인증 정보를 확인하고, 인증된 사용자에게 서명된 토큰(예: JWT, JSON Web Token)을 발급.<br>
사용자는 이후의 요청에 이 토큰을 포함시켜 서버에 전송하고, 서버는 토큰의 유효성을 검증하여 사용자를 인증.

- 장점
<br>: 세션 상태를 클라이언트 측에서 관리하므로 서버의 부하를 줄일 수 있고, 서버간의 세션 공유 문제를 해결할 수 있다.
<br>: 확장성이 뛰어나며, 다양한 플랫폼과 장치에서 사용하기 적합.
<br>: 분산 시스템과 마이크로서비스 아키텍처에 잘 맞다.

- 단점
<br>: 토큰이 탈취되면, 악의적인 사용자가 사용자의 권한을 얻을 수 있으므로 보안에 주의해야 함.
<br>: 토큰의 유효 기간 관리가 필요.

- 적합한 적용 사례
<br>: 대규모 분산 시스템, 마이크로서비스 아키텍처, 모바일 애플리케이션, 싱글 페이지 애플리케이션(SPA), 다양한 플랫폼과 장치를 지원해야 하는 웹 서비스에서 효과적.

---
**🔍 18. CORS에 대해 설명해주세요.**

 다른 출처의 리소스를 공유할 수 있게 하는 웹 보안 메커니즘.<br>
 웹에서는 보안상의 이유로 같은 출처 정책(Same-Origin Policy)을 적용하여, 한 출처에서 불러온 스크립트가 다른 출처의 리소스와 상호작용하는 것을 기본적으로 제한함.<br>
 
예를 들어, https://example.com에서 실행 중인 JavaScript 코드가 https://another-domain.com의 API를 호출하는 것은 보안 정책에 의해 차단된다.<br>

CORS는 이러한 제한을 안전하게 완화할 수 있는 방법을 제공.

- CORS 작동 방식
<br>: CORS는 HTTP 헤더를 사용하여 브라우저와 서버 간에 어떤 출처가 리소스에 접근할 수 있는지 협상. 
<br>: 웹 애플리케이션에서 다른 출처의 리소스를 요청할 때, 브라우저는 자동으로 CORS 요청을 수행. 이때, 요청에는 Origin 헤더가 포함되어 출처 정보를 서버에 전달. 서버는 이 정보를 검토하여 해당 출처의 요청을 허용할지 결정하고, 응답에 Access-Control-Allow-Origin 헤더를 포함시켜 이를 브라우저에 알림. 브라우저는 서버의 응답을 확인하고, 정책에 따라 요청을 허용하거나 차단한다.


- CORS 요청 유형<br>
    - 단순 요청(Simple Requests): 특정 조건(메서드가 GET, HEAD, POST 중 하나이고, 특정 헤더만 사용하는 등)을 충족할 때, 브라우저는 추가 CORS 사전 체크(pre-flight) 없이 바로 요청을 보냄.
    - 사전 체크가 필요한 요청(Pre-flight Requests): 단순 요청의 조건을 충족하지 않는 경우, 브라우저는 실제 요청을 보내기 전에 OPTIONS 메서드를 사용하여 서버의 허용 정책을 사전에 체크하는 요청을 보냄.

- CORS 구현
<br>: 서버 측에서는 다음과 같은 HTTP 응답 헤더를 설정하여 CORS 요청을 처리할 수 있다
  - Access-Control-Allow-Origin: 특정 출처 또는 *(모든 출처)로부터의 요청을 허용.
  - Access-Control-Allow-Methods: 서버가 허용하는 HTTP 메서드를 지정.
  - Access-Control-Allow-Headers: 서버가 허용하는 헤더를 지정.
  - Access-Control-Allow-Credentials: 인증 정보(쿠키, HTTP 인증 등)와 함께 요청을 보낼 수 있는지 여부를 지정.
  
---
**🔍 19. 유니캐스트, 브로드캐스트, 멀티캐스트, 애니캐스트에 대해 설명해주세요.**

네트워크 상에서 데이터를 전송하는 방식을 설명할 때 사용되는 용어

### 유니캐스트(Unicast)

 네트워크상에서 한 대의 송신자가 단일 수신자에게 데이터 패킷을 전송하는 방식 
 - 사용 사례: 대부분의 인터넷 통신(웹 페이지 요청, 이메일 전송 등)
 - 특징: 네트워크 효율성이 높고, 특정 송수신자 간의 직접적인 데이터 전송이 필요할 때 적합합니다. 
### 브로드캐스트(Broadcast)
 브로드캐스트는 네트워크상의 한 대의 송신자가 동일한 네트워크 내의 모든 장치에 데이터 패킷을 전송하는 방식.
 - 사용 사례: 로컬 네트워크상에서 장치나 서비스를 탐색하거나, DHCP에서 IP 주소를 할당받을 때 사용.
 - 특징: 브로드캐스트는 네트워크의 모든 장치가 메시지를 받기 때문에 효율성이 낮을 수 있다. 
### 멀티캐스트(Multicast)
한 대 이상의 송신자가 특정 멀티캐스트 그룹에 속한 여러 수신자에게 데이터 패킷을 전송하는 방식입니다.
- 사용 사례: IPTV, 실시간 스트리밍, 온라인 게임 등에서 사용.
- 특징: 멀티캐스트는 네트워크 트래픽을 최소화하면서 여러 수신자에게 효율적으로 데이터를 전송할 수 있다. 
### 애니캐스트(Anycast)
 여러 장치가 같은 주소를 공유하고 있을 때, 송신자로부터 가장 가까운 하나의 장치에 데이터 패킷을 전송하는 방식.
 - 사용 사례: DNS 서버에 요청을 보낼 때 사용되며, 사용자에게 가장 가까운 서버에서 응답을 제공.
 - 특징: 애니캐스트는 네트워크 지연 시간을 줄이고, 부하 분산을 통해 서비스의 신뢰성을 높일 수 있다.

---
**🔍 20. JWT 토큰에 대해 설명해주세요.**

 인터넷 표준으로, 두 개체 사이에서 JSON 객체를 사용하여 가볍고 자가 수용적인(self-contained) 방식으로 정보를 안전하게 전송하기 위한 컴팩트하고 독립적인 방법을 정의.
 JWT는 주로 사용자 인증 및 정보 교환에 널리 사용

### JWT의 구조
JWT는 세 부분으로 구성되어 있으며, 각 부분은 점('.')으로 구분됨

- 헤더(Header): 토큰의 타입(주로 JWT)과 사용된 서명 알고리즘(예: HMAC SHA256 또는 RSA)을 지정하는 JSON 객체.
- 페이로드(Payload): 실제로 전송될 클레임(claims)을 담고 있는 JSON 객체. 클레임은 토큰에 대한 속성으로, 사용자의 식별 정보, 토큰의 발행자, 유효 기간 등이 포함될 수 있다.
- 서명(Signature): 헤더와 페이로드를 기반으로 생성된 서명으로, 토큰의 무결성과 정보의 검증을 위해 사용된다. 서명은 헤더와 페이로드를 합친 후, 비밀 키나 공개/비공개 키 쌍과 함께 알고리즘을 사용하여 생성됨.

### JWT의 작동 방식
- 사용자가 로그인을 시도하면, 서버는 사용자의 인증 정보를 검증.
- 인증이 성공하면, 서버는 사용자의 정보(예: 사용자 ID, 권한 등)를 포함한 JWT를 생성하고, 이를 서명하여 사용자에게 발급.
- 사용자는 이후의 요청에 JWT를 포함시켜 서버에 전송.
- 서버는 요청을 받을 때마다 JWT의 서명을 검증하고, 페이로드를 해석하여 사용자를 인증.
- JWT의 유효성이 확인되면, 서버는 요청된 작업을 수행.

### JWT의 장점
- 자가 수용적: JWT는 필요한 모든 정보를 자체적으로 포함하고 있어, 상태를 서버에 저장할 필요가 없다. 이는 무상태 인증 메커니즘을 가능하게 함.
- 컴팩트: 작은 크기로 인해 HTTP 헤더에 쉽게 포함될 수 있으며, 네트워크를 통한 전송에 효율적.
- 확장성: 다양한 도메인과 서비스 간에 안전하게 정보를 전달할 수 있다.

### JWT의 단점
- 보안 취약성: 토큰이 탈취될 경우, 탈취자는 토큰의 유효 기간 동안 사용자의 권한을 가질 수 있다. 따라서, HTTPS를 통한 안전한 전송과 함께 토큰의 만료 시간을 적절히 관리하는 것이 중요.
- 토큰 크기: 페이로드에 많은 정보를 포함할수록 JWT의 크기가 커질 수 있으며, 이는 네트워크 성능에 영향을 줄 수 있음.

---
**🔍 21. Connection timeout 과 Read timeout의 차이에 대해 설명해주세요.**

### Connection Timeout
클라이언트가 서버에 연결을 시도할 때까지 기다리는 최대 시간을 의미. 이 시간 내에 클라이언트가 서버와의 초기 연결을 설정하지 못하면, 연결 시도는 실패로 간주.
- 상황: 이 타임아웃은 주로 네트워크 지연, 서버 다운, 또는 서버가 너무 바빠서 새로운 연결 요청을 처리할 수 없는 경우 발생.
- 예시: 사용자가 웹 사이트에 접속을 시도할 때, 브라우저가 서버와의 연결을 설정하는 데 실패하고, "서버에 연결할 수 없습니다"와 같은 메시지를 표시할 수 있다.
### Read Timeout
클라이언트가 서버로부터 데이터를 읽기 시작한 후 최대 대기 시간을 의미. 연결이 성공적으로 설정된 후, 클라이언트가 서버로부터 응답(데이터)을 기다리는 시간이 이 타임아웃을 초과하면, 요청은 실패로 간주됨.
- 상황: 서버가 요청을 받고 처리하는 데 너무 오래 걸리거나, 네트워크 상의 문제로 데이터 패킷이 손실되는 경우 발생할 수 있다.
- 예시: 사용자가 웹 페이지의 양식을 제출하고 결과를 기다릴 때, 서버가 응답을 보내기까지 너무 오래 걸려 "요청 시간 초과"와 같은 메시지가 표시될 수 있다.

### 요약
Connection timeout은 서버에 처음 연결을 시도할 때 발생하는 지연에 대한 타임아웃이며, 서버와의 연결을 설정하는 초기 단계에 적용된다.
Read timeout은 연결이 성공적으로 설정된 후, 서버로부터 데이터를 수신하는 과정에서 발생하는 지연에 대한 타임아웃이다.


---
**🔍 22. IOCP에 대해 설명해주세요.**

### IOCP(Input/Output Completion Port)
- Windows 운영 체제에서 제공하는 고성능 네트워크 프로그래밍 인터페이스
- 본질적으로, IOCP는 비동기 입출력(Asynchronous I/O) 작업을 효율적으로 처리하기 위한 메커니즘을 제공.
- 이를 통해 서버 애플리케이션은 높은 수준의 동시성과 스케일러빌리티를 달성할 수 있다. 
- 주로 대규모 클라이언트 연결을 관리해야 하는 네트워크 서버, 데이터베이스 서버 및 파일 서버와 같은 애플리케이션에서 사용.
- I/O 작업이 애플리케이션의 스레드를 블로킹하지 않기 때문에, 스레드를 보다 생산적인 작업에 사용할 수 있도록 함.

### IOCP의 주요 특징
- **비동기 입출력 지원**
<br>: 입출력 작업이 완료될 때까지 기다리지 않고, 다른 작업을 계속 처리할 수 있게 함. 이는 리소스의 효율적 사용을 가능하게 하여 애플리케이션의 전반적인 성능을 향상시킴.
- **커널 객체와의 통합**
<br>: 운영 체제의 커널 모드와 밀접하게 통합되어 있어, 입출력 작업의 완료를 효과적으로 관리할 수 있다. 이는 컨텍스트 스위칭을 최소화하고, 고성능을 제공
- **동시성 관리**
<br>: IOCP는 스레드 풀을 사용하여 동시에 실행되는 입출력 작업의 수를 관리합니다. 이를 통해 개발자는 동시성에 대해 신경 쓰지 않고, 애플리케이션 로직에 집중할 수 있습니다.
- **확장성**
<br>: IOCP는 많은 수의 클라이언트 연결을 효율적으로 처리할 수 있도록 설계되었습니다. 이는 고성능 네트워크 서버 애플리케이션의 개발에 매우 적합합니다.
### IOCP의 작동 원리
- **비동기 입출력 요청**
<br>: 애플리케이션은 비동기 입출력 작업(예: 파일 읽기/쓰기, 소켓 연산)을 시작하고, 작업이 완료될 때까지 기다리지 않는다.
- **작업 완료 알림**
<br>: 비동기 입출력 작업이 완료되면, 해당 작업의 결과와 함께 완료 알림이 IOCP에 전달된다.
- **완료 처리**
<br>: IOCP에 연결된 스레드 풀의 스레드 중 하나가 작업 완료 알림을 받아 처리한다. 이 과정에서 입출력 작업의 결과를 애플리케이션에 전달하거나, 추가 작업을 수행할 수 있다.

---
**🔍 23. POLLING은 무엇인지 설명해주세요.**

하나의 장치나 프로그램이 다른 시스템, 장치, 또는 서비스의 상태를 주기적으로 체크하는 과정.<br>
이 기법은 특정 조건이나 상태의 변화를 감지하기 위해 반복적으로 상태를 확인하는 방식으로 작동함.

### 폴링의 주요 특징
- **주기적인 체크**
<br>: 폴링은 정해진 시간 간격으로 특정 상태나 이벤트의 발생 여부를 확인함. 이 시간 간격은 폴링 주기라고 하며, 애플리케이션의 요구 사항에 따라 조절될 수 있다.
- **자원 사용**
<br>: 폴링은 CPU나 네트워크 같은 자원을 사용하여 상태를 주기적으로 확인함. 폴링 주기가 짧으면 짧을수록 더 많은 자원을 소모하게 됨.
- **반응 시간**
<br>: 폴링 기반 시스템의 반응 시간은 폴링 주기에 의존적이다. 폴링 주기가 길면 시스템이 상태 변화에 반응하는 데 더 많은 시간이 소요됨.

### 폴링의 사용 사례
- **하드웨어 인터페이스**
<br>: 컴퓨터가 키보드, 마우스 등의 입력 장치로부터 사용자의 입력을 감지할 때 폴링을 사용할 수 있다.
- **네트워크 통신**
<br>: 클라이언트 애플리케이션은 서버로부터 새로운 데이터나 이벤트가 있는지 확인하기 위해 주기적으로 요청을 보낼 수 있다.
- **임베디드 시스템**
<br>: 센서 데이터를 읽거나 장치의 상태를 확인하기 위해 임베디드 시스템에서 폴링을 사용할 수 있다.

---
**🔍 24. 대칭키, 비대칭키 암호화 방식에 대해 설명해주세요.**

### 대칭키 암호화(Symmetric Key Encryption)
대칭키 암호화 방식에서는 암호화와 해독 과정에 동일한 키를 사용. 이 키를 대칭키 또는 비밀키라고 하며, 송신자와 수신자만이 이 키를 알고 있어야 한다.

#### 특징
- 속도: 대칭키 암호화는 비대칭키 암호화에 비해 계산이 더 간단하고 빠름.
- 키 관리: 통신하는 각 당사자 간에 안전하게 키를 공유해야 하는 키 관리 문제가 있다.
- 사용 사례: 대량의 데이터를 암호화해야 하는 상황(예: 파일 시스템 암호화, 데이터베이스 암호화)에서 주로 사용.

### 비대칭키 암호화(Asymmetric Key Encryption)
비대칭키 암호화에서는 두 개의 키를 사용하는데, 하나는 공개 키(public key)이고 다른 하나는 개인 키(private key) 또는 비밀 키(secret key)이다.<br> 
공개 키는 누구에게나 공개될 수 있으며, 개인 키는 키의 소유자만이 보유해야 한다. 송신자는 수신자의 공개 키로 데이터를 암호화하고, 수신자는 자신의 개인 키로 데이터를 해독한다.

#### 특징

- 보안성: 공개 키와 개인 키가 쌍을 이루며, 개인 키는 공개되지 않기 때문에 보안성이 높다.
- 속도: 대칭키 암호화에 비해 계산 과정이 복잡하고 느리다.
- 키 관리: 공개 키는 자유롭게 공유할 수 있으므로, 대칭키 방식에 비해 키 관리가 쉽다.
- 사용 사례: 디지털 서명, SSL/TLS를 통한 안전한 웹 통신, 이메일 암호화 등에서 사용.

---
**🔍 25. DNS란 무엇인지 설명해주세요.**

사람이 읽을 수 있는 도메인 이름(예: www.example.com)을 컴퓨터가 처리할 수 있는 IP 주소(예: 192.0.2.1)로 변환하는 분산형 디렉토리 서비스<br>
인터넷 상의 장치들이 서로 통신할 수 있게 해 주며, 사용자가 웹사이트에 접속할 때 필요한 주소 변환을 책임진다.

### DNS의 기본 작동 원리
- **사용자의 요청**: 사용자가 웹 브라우저에 도메인 이름을 입력하면, 이 요청은 먼저 사용자의 장치에 설정된 DNS 서버로 전송됨.
- **DNS 조회**: 지정된 DNS 서버는 해당 도메인 이름에 대한 IP 주소를 찾기 위해 조회 과정을 시작. 이 서버가 요청된 정보를 가지고 있지 않다면, 다른 DNS 서버로 요청을 전달하여 필요한 정보를 찾는다.
- **응답**: 최종적으로 IP 주소가 확인되면, 이 정보는 사용자의 장치로 전송되어 웹 브라우저가 해당 주소의 서버에 접속할 수 있게 한다.

### DNS 구조
- **루트 서버(Root Server)**: DNS 계층 구조의 최상위에 위치하며, 전 세계에 걸쳐 분산되어 있음. 루트 서버는 최상위 도메인(TLD, Top-Level Domain) 서버의 주소를 알려준다.
- **TLD 서버(Top-Level Domain Server)**: 최상위 도메인(예: .com, .net, .org 등)에 대한 정보를 관리. TLD 서버는 해당 도메인의 네임 서버 정보를 알려준다.
- **권한있는 네임 서버(Authoritative Name Server)**: 특정 도메인에 대한 구체적인 정보(예: IP 주소)를 가지고 있으며, DNS 조회 요청에 최종적으로 응답한다.

### DNS 중요성
- **사용자 친화적인 인터넷 사용**: 사람들이 기억하기 쉬운 도메인 이름을 통해 웹사이트에 접속할 수 있게 해 줌.
- **인터넷의 안정성과 유연성**: DNS는 도메인 이름을 IP 주소로 변환하는 중요한 역할을 하므로, 웹사이트의 IP 주소가 변경되어도 도메인 이름은 그대로 유지될 수 있다.
- **부하 분산**: 여러 서버에 트래픽을 분산시켜 주는 역할을 하여, 인터넷 서비스의 가용성과 신뢰성을 높여준다.