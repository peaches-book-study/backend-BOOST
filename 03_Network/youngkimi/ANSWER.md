# 네트워크 예상질문 리스트

1. TCP와 UDP에 대해 설명하고, TCP와 UDP의 차이에 대해 설명해주세요 ⭐️⭐️⭐️⭐️⭐️
2. TCP에서 데이터의 신뢰성을 보장하기 위한 방법은 어떤 것이 있는지 설명해주세요. ⭐️
   1. 오류제어란 ?
   2. 혼잡제어란 ?
3. 3-way handshaking과 4-way handshaking에 대해 설명해주세요. ⭐️⭐️⭐️
4. 사용자가 URL을 입력한 후 화면이 출력되기까지의 과정을 설명해주세요 \*\*\*\*⭐️⭐️⭐️⭐️⭐️
5. HTTP 프로토콜에 대해 설명해주세요 ⭐️⭐️⭐️
6. HTTP와 HTTPS의 차이점에 대해서 설명해주세요. ⭐️⭐️⭐️⭐️⭐️
   1. 암호화 방식
7. HTTP 1.0과 1.1의 차이에 대해 설명하세요. ⭐️⭐️⭐️
8. 쿠키(Cookie)와 세션(Session)의 차이점에 대해 설명해주세요 ⭐️⭐️
9. OSI 7 layer와 각 계층에 대해 아는대로 설명해주세요. ⭐️⭐️⭐️⭐️
10. TCP/IP 프로토콜을 스택 4계층으로 설명해주세요. ⭐️⭐️
11. HTTP에서 사용되는 Method와 각 용도에 대해서 설명해주세요. ⭐️⭐️⭐️
12. GET과 POST의 차이를 설명하세요. ⭐️⭐️⭐️⭐️
13. REST(REST API)에 대해 설명하고 RESTful이란 무엇인지 설명해주세요. ⭐️⭐️
14. 공인(public) IP와 사설(private) IP의 차이에 대해 설명해주세요. ⭐️⭐️⭐️
15. 라우팅 알고리즘에 대해서 설명해주세요
16. 라우터와 스위치의 차이에 대해 설명해주세요. ⭐️
17. 세션 기반 인증과 토큰 기반 인증의 차이에 대해 설명하고, 어느 경우에 적합한지 설명해주세요. ⭐️⭐️
18. CORS에 대해 설명해주세요.
19. 유니캐스트, 브로드캐스트, 멀티캐스트, 애니캐스트에 대해 설명해주세요.
20. JWT 토큰에 대해 설명해주세요. ⭐️
21. Connection timeout 과 Read timeout의 차이에 대해 설명해주세요. ⭐️⭐️
22. IOCP에 대해 설명해주세요.
23. POOLING은 무엇인지 설명해주세요.
24. 대칭키, 비대칭키 암호화 방식에 대해 설명해주세요.
25. DNS란 무엇인지 설명해주세요.

---

## 🔍 1. TCP와 UDP에 대해 설명하고, TCP와 UDP의 차이에 대해 설명해주세요 ⭐️⭐️⭐️⭐️⭐️

둘 모두 네트워크 통신 프로토콜.

### TCP : Transmission Control Protocol

- 연결 지향
- 연결 후 클라이언트의 소켓과 서버의 소켓이 1:1 매칭
- 이후 응답 종료까지 연결 유지
- 전송되는 패킷의 순서 보장 (패킷에 sequence 작성)
- 패킷의 에러뿐 아니라, 손실에 대해서도 안전.
- Sender 버퍼를 통한 임시 저장. window size와 연관.
- 신뢰성이 중요한 서비스에 사용.

### UDP : User Datagram Protocol

- 비연결 방식
- 패킷의 순서, 손실에 대해 보장해주지 않음.
- 패킷의 에러는 확인해줌 (checksum 활용)
- 버퍼링 X.
- 음성, 영상 스트리밍 등 실시간성이 중요한 서비스 / 신뢰성이 중요하지 않은 서비스 사용.

## 🔍 2. TCP에서 데이터의 신뢰성을 보장하기 위한 방법은 어떤 것이 있는지 설명해주세요. ⭐️

### 1. 오류 제어

#### 1. sequence number : 패킷의 순서 신뢰성 보장

- 데이터를 패킷 단위로 자를 때, sequence number로 순서를 기록
- 이후 수신 서버에서 sequence number 맞추어서 패킷 수신

#### 2. ack number : 패킷 손실, 에러에 대한 신뢰성 보장

- (마지막 수신 성공 number+1)를 ack number에 담아 Ack 전송
- 패킷 손실이나 에러로 인해 기다리는 sequence number의 packet이 오지 않으면 ack number 유지.
- 반복적인 ack number 수신 시, 해당 packet 재전송.

#### 3. checksum

- 아주 간단한 패킷 에러 검사
- 일련의 비트 숫자합, 혹은 해시값
- 수신 후에 체크섬과 대조, 유효성 확인

### 2. 혼잡 제어

혼잡 제어가 필요한 이유

- TCP는 패킷의 재전송을 통해 신뢰성을 확보한다.
  패킷이 전송량이 너무 많아서 패킷이 손실되는 경우, 패킷을 재전송 한다.
  즉, 상태가 안좋을 수록 상태를 더욱 악화시킨다.

#### 2. window size 활용

- 수신 측에서 헤더의 window size를 통해 현재 수신 가능한 사이즈를 전송한다.
- 송신 측에서 이를 고려하여 데이터를 전송한다.
- window size가 작아도, 아주 작은 패킷을 주고 받아야 엣지 케이스 회피 가능.

#### 3. optimization

- 초기에는 송신 데이터 크기를 선형으로 증가시킴.
- loss 발생 시에는 데이터 크기를 절반 수준으로 감소시킴.
  - loss case에 따라서도 optimization 가능
  - dup ack seq / time expired 라는 두 가지 loss case
  - 이중 time expired의 경우 송신 데이터 더 크게 감소
- window size가 작은 경우에는 0으로 퉁침.
  - 너무 작으니까 조금 모아 받기 위해서
- delayed ack

## 🔍 3. 3-way handshaking과 4-way handshaking에 대해 설명해주세요. ⭐️⭐️⭐️

### 3-way handshaking

클라이언트와 서버가 TCP 연결을 맺기 위한 과정

- 클라이언트가 서버에게 연결 희망 의사를 밝힘 (SYN)
- 서버가 응답. 포트 넘버를 전달함 (SYN / ACK)
- 클라이언트가 이에 응답 (ACK)

### 4-way handshaking

클라이언트와 서버가 TCP 연결을 끊기 위한 과정

- 한 쪽(A)이 연결 종료 의사를 밝힘 (FIN)
- 반대편(B)이 의사 확인 메세지 전달 (ACK)
- B가 현재 작업이 완료된 이후 종료 메세지 전달 (FIN)
- B의 종료 메세지를 수신한 A도 연결 종료 후 ACK 메세지 전송. (ACK)

## 🔍 4. 사용자가 URL을 입력한 후 화면이 출력되기까지의 과정을 설명해주세요 ⭐️⭐️⭐️⭐️⭐️

1. URL 입력 - DNS 서버를 통해서 IP 주소로 변환. DNS 캐시에 해당 정보 저장.
2. 현재 내 IP와 목적지의 IP 비교.

- 1. 둘의 네트워크 ID가 다르다면

  - 목적지의 IP 주소를 라우터의 주소로 변환.
  - 라우터의 ARP 캐시 테이블에서 라우터의 MAC 주소 찾음
  - 없으면 주변 호스트로 ARP 질의 (브로드캐스트).
  - 라우터의 MAC 주소를 찾았다면 ARP 테이블에 기록 후 패킷 목적지의 MAC 주소를 라우터의 MAC 주소로 기록.

- 2. 둘의 네트워크 ID가 같다면

  - 같은 서브넷에 속해 있다는 뜻. 라우터를 찾을 필요 없음.
  - 2-1 에서와 같은 방식으로 캐시 테이블, ARP 쿼리로 목적지의 MAC를 찾음.
  - 목적 호스트의 MAC을 찾는다면 직접 통신 (완료).

3. 라우터로 패킷 전달.

- 이후 라우터는 라우팅 과정을 통해 인접한 라우터로 패킷을 전달하며 목적지로 이동
- 라우터에서 나가는 과정
  - NAT을 통해 내부 IP를 외부 IP로 변환

4. 위의 방식으로 먼저 TCP 연결 요청. (HTTP), `3-way handshake`로 TCP 연결

5. TCP 연결 후 데이터 (html, css, javascript) 주고 받음.

- 데이터를 주고 받는 과정에서 데이터 단편화.
- 단편화하며 sequence number 입력

6. 이후 통신 완료 시 `4-way handshake` TCP 연결 종료. 데이터를 `WebResource`를 디스크에 캐싱

7. 다시 통신 시에는 `DNS 캐시`와 `Web Resource 캐시`를 통해서 이전보다 빠르게 통신 가능.

## 5. HTTP 프로토콜에 대해 설명해주세요 ⭐️⭐️⭐️

- HyperText Transfer Protocol
- 서로 다른 호스트가 데이터(문서)를 주고 받기 위한 프로토콜

  1. Connectless

  - 응답 뒤에 연결을 유지하지 않고 끊어버림.

  2. Stateless

  - 각각의 요청은 서버에서 독립적으로 처리.
  - 이전 요청의 상태에 대해서 기억하지 않음.

## 6. HTTP와 HTTPS의 차이점에 대해서 설명해주세요. ⭐️⭐️⭐️⭐️⭐️

- HTTPS는 HTTP에 SSL/TLS 인증을 더한 것.
- HTTP는 데이터를 주고 받을 때 암호화하지 않는다. 누군가 패킷을 탈취하면 페이로드를 직접 확인, 위변조할 수 있어 보안에 취약하다.
- 이런 보안상의 취약점을 해결하기 위해 HTTPS를 사용한다. HTTPS는 데이터를 암호화하여 전달하는 것이다.

## 7. HTTP 1.0과 1.1의 차이에 대해 설명하세요. ⭐️⭐️⭐️

- TCP 커넥션 유지
  - HTTP 1.0은 응답을 받은 후 TCP 연결을 종료한다. HTTP 1.1에서는 연결을 유지하므로 한 TCP 연결을 재사용할 수 있다.
  - 여전히 `Stateless`. TCP 커넥션 유지를 통해서 기존 매 요청마다 맺었던 TCP 연결 과정 (Handshake 등)을 생략할 수 있다.
- 파이프라이닝
  - 하나의 연결에서 여러 요청과 응답을 동시처리할 수 있다.
- 호스트 헤더
  - 하나의 서버가 여러 도메인을 처리할 수 있다.
- 추가 헤더
  - 추가적인 헤더 정보를 전달할 수 있다.
- 청크 전송 인코딩
  - Body의 크기를 알 수 없는 응답을 보낼 수 있다.

## 8. 쿠키(Cookie)와 세션(Session)의 차이점에 대해 설명해주세요 ⭐️⭐️

- 둘 모두 HTTP 의 `Stateless`를 극복하기 위한 방법.

### 쿠키 Cookie

- 클라이언트와 서버가 주고 받는 요청에서 쿠키를 같이 전송.
- 이를 통해서 서버는 클라이언트의 이전 State를 유추할 수 있음.
- 인증 정보 / 사용자의 선호 / 장바구니 정보 등을 활용
- 쿠키는 클라이언트 측에 저장되므로 보안에 취약할 수 있음.

### 세션 Session

- 서버 측에서 사용자의 정보를 저장하는 방법.
- 사용자에게 세션을 할당. 사용자의 요청마다 할당한 세션 ID를 같이 보냄.
- 세션 정보는 서버의 메모리나 DB에 저장.
- 쿠키에 비해서는 보안성이 좋지만, 서버에 부하가 갈 수 있음.

## 9. OSI 7 layer와 각 계층에 대해 아는대로 설명해주세요. ⭐️⭐️⭐️⭐️

OSI 7 Layer란 네트워크 통신에서 사용되는 프로토콜을 계층적으로 분류하여 정의한 모델.
어플리케이션 계층, 표현 계층, 세션 계층, 전송 계층, 네트워크 계층, 데이터 링크 계층, 물리 계층으로 구성.

1. 물리 계층

- 물리적인 통신 매체로 비트를 전송

2. 데이터 링크 계층

- 물리 계층에서 오류없이 데이터를 전달하기 위한 작업 수행
- 데이터 전송 단위 : 프레임

3. 네트워크 계층

- IP 주소를 할당하고 패킷을 라우팅하는 계층
- 라우팅을 통해서 패킷을 목적지까지 전달
- 데이터 전송 단위 : 패킷

4. 전송 계층

- 데이터를 전송하기 위한 TCP/UDP 등의 프로토콜 정의
- 흐름 제어, 오류 복구, 재전송 등의 작업 수행
- 데이터 전송 단위 : 세그먼트

5. 세션 계층

- 데이터 교환의 시작, 종료, 동기화 등 관리
- 세션 설정, 해제, 메세지 전송의 기능 수행

6. 표현 계층

- 데이터 변환, 압축, 암호화와 복호화 등의 기능 수행

7. 어플리케이션 계층

- 사용자와 가장 가까이에 있는 계층
- HTTP, SMTP 등의 프로토콜 사용

## 10. TCP/IP 프로토콜을 스택 4계층으로 설명해주세요. ⭐️⭐️

1. 응용 계층

- OSI 7계층에서 어플리케이션 계층에 대응
- 전송하기 위한 데이터(페이로드)를 생성, 전송하는 계층
- 데이터 전송 단위는 메세지
- 메세지 작성, 이후 전송 계층으로 전달.

2. 전송 계층

- OSI 7계층에서 전송 계층에 대응
- 응용 계층에서 넘어온 메세지에 헤더를 붙임.
- 데이터 전송 단위는 세그먼트(데이터그램)
- 헤더에는 발송 포트와 수신 포트 기록

3. 네트워크 계층

- OSI 7계층에서 네트워크 계층에 대응
- 응용 계층에서 넘어온 세그먼트에 헤더를 붙임.
- 데이터 전송 단위는 패킷
- 헤더에는 발송 ip와 수신 ip 기록

4. 네트워크 인터페이스 계층

- OSI 7 계층에서 데이터 링크 계층과 물리 계층에 대응되는 계층.
- 네트워크 계층에서 넘어온 패킷에 헤더를 붙임.
- 데이터 전송 단위는 프레임
- 헤더에는 MAC 주소 기록

## 11. HTTP에서 사용되는 Method와 각 용도에 대해서 설명해주세요. ⭐️⭐️⭐️

- `GET` : 서버에 리소스 요청. 일반적으로 URL 상에 쿼리 스트링을 담아서 전달.
- `POST` : 서버에 리소스 추가를 요청. Request Body에 데이터를 담아서 전달.
- `PUT` : 서버에 리소스 수정 (대치)
- `PATCH` : 서버에 리소스 수정 (일부 값 수정)
- `DELETE` : 서버에서 리소스 삭제
- `OPTION` : Preflight (본 요청 전 예비 요청). 요청의 타당성 검증용.

#### Preflight 생략 조건.

1. HTTP Method가 `GET`, `POST`, `HEAD`
2. `Accept`, `Accept-Language`, `Content-Language`, `Content-Type`, `DPR`, `Downlink`, `Save-Data`, `Viewport-Width`, `Width` 헤더일 경우 에만 적용된다.
3. `Content-Type` 헤더가 `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`중 하나여야한다.

위 조건을 맞추기 까다롭다. 그래서 일반적인 API 요청은 Preflight 방식으로 작동한다.

## 12. GET과 POST의 차이를 설명하세요. ⭐️⭐️⭐️⭐️

- 둘 다 HTTP METHOD 중 하나.
- GET은 서버에서 자원을 요청하는 경우에 사용한다.
  - 일반적으로 쿼리 스트링을 URL을 통해 전달한다.
- POST는 서버에 리소스 추가를 요청하는 경우에 사용한다.
  - 데이터를 본문(Body)에 담아 전달한다.

## 13. REST(REST API)에 대해 설명하고 RESTful이란 무엇인지 설명해주세요. ⭐️⭐️

### REST API

`REST` 아키텍쳐 스타일을 따르는 API를 REST API라고 한다.
`REST` 아키텍쳐를 구현하는 걸 RESTful 하다고 한다.
`REST`는 REpresentational State Transfer의 약자.
HTTP Method, HTTP Status, Resource(URI)를 통해 API를 구성하는 것.

### 구성 요소

`REST` = `Resource` + `HTTP Method` + `HTTP Status`

1. Resource : 정보의 자원. URI를 통해서 표현.
2. HTTP Method : 자원에 대한 행위. `GET`, `POST`, `DELETE`, `PATCH`, `PUT` ...
3. HTTP Status : 결과에 대한 표현. `OK(200)`,`BAD REQUEST(400)`, `NOT FOUND(404)`, `INTERNAL SERVER ERROR(500)`, ...

### REST 6원칙

1. Uniform Interface (균일한 인터페이스)

- 서버는 표준 형식으로 정보를 전송한다. (어플리케이션 내부 구현과는 달라도)
- 요청은 리소스를 식별해야 한다. 균일한 리소스 식별자를 사용한다.
- 서버는 요청을 받으면 리소스를 자세히 설명하는 메타데이터를 전송한다.

2. Stateless

- 작업을 위한 상태 정보를 저장, 관리하지 않는다.
- 각 요청은 완결성이 있어야 한다.
- 자유도가 높아지고 구현이 단순해진다.

3. Cacheable

- 클라이언트, 중개자에 일부 응답을 저장할 수 있다.
- 웹 리소스를 캐싱하여 다음 캐시에서 사용할 수 있다.
- 서버는 캐시 가능, 불가능을 정의하는 API 응답을 사용하여 캐싱을 제어한다.

4. Self-descriptiveness

- HTTP Method, Resource 등으로 자기 자신을 서술하는 자체 표현 구조를 가져야 한다.
- REST API 메세지만 보더라도 무슨 API인지 쉽게 이해할 수 있다.

5. Client-Server

- 클라이언트와 서버로 분리되어야 하며, 서로 의존성이 없어야 한다.

6. 계층화 시스템

- 계층화 시스템을 통해 클라이언트-서버 사이 다른 중개자(프록시, 게이트웨이)에게 연결할 수 있다.
- 내부를 다중 계층으로도 구성할 수 있으며 보안, 로드밸런싱, 암호화 계층을 추가해 구조적 유연성을 둘 수 있다.

## 14. 공인(public) IP와 사설(private) IP의 차이에 대해 설명해주세요. ⭐️⭐️⭐️

### IP 주소의 고갈 위험

가능한 공인 IPv4의 개수는 `2^32 = 약 43억 개`. 인터넷 수요의 증가에 따라 IP 주소는 이미 고갈되었음.
이를 해결하고자 IPv6을 고안했지만, 현실적으로 사용되지 못하고 있음.
고갈된 IPv4를 일종의 트릭을 통해서 사용. 이것이 사설 IP이다.

### IP의 구분

1. 고정 IP

- 말 그대로 고정된, 변하지 않는 IP.

2. 유동 IP

- 임시로 발급받아 사용하는 IP. 인터넷 사용자들 모두에게 고정 IP를 발급하기는 어려움이 있다.
- 일정한 주기, 혹은 사용자들이 인터넷에 접속하는 순간에 일정 기간 사용할 임시 IP를 발급해준다.

3. 공인 IP

- ISP(Internet Service Provider)들이 받아서 인터넷 사용자들에게 할당해주는 IP
- ISP들도 보다 상위 기관 (ICANN)에서 사용할 IP 대역을 받아 할당한다.

4. 사설 IP

- 특정 네트워크 내부적으로 사용하는 IP.
- 공인 IP는 전 세계에서 유일하지만, 사설 IP는 특정 네트워크 내부에서만 유일하다.
- 공유기를 사용한 인터넷 접속 환경에서 공유기까지는 공인 IP를 할당한다.
- 공유기에 연결된 네트워크 기기들은 사설 IP를 할당하여 사용한다.

#### 사설 IP와 사설 네트워크

- 공유기까지는 공인 IP를 할당한다. 하지만 다른 네트워크 기기는 사설 IP를 할당한다.
- 사설 IP를 할당 받은 내부 네트워크 기기는 게이트웨이(Gateway)를 통해 외부와 요청을 주고 받는다.
- 사설 네트워크는 지정된 대역의 IP만을 사용한다. 리눅스의 `10.0.0.0`, `192.168.0.0` 번대 IP가 사설 IP이다.

#### NAT(Network Address Translation)

- 사설 IP와 공인 IP를 변환해주는 서버
- 요청이 나갈 때, 사설 IP를 캐시 테이블에 적고 나간다. 이후 공인 IP로 변환해서 요청을 외부로 보낸다.
- 외부에서 응답이 들어올 때, 캐시 테이블을 참조, 공인 IP를 확인하여 사설 IP로 변환해준다.

## 15. 라우팅 알고리즘에 대해서 설명해주세요

#### 거리 벡터(Distance Vector) 알고리즘

- 자신의 라우팅 정보를 주기적으로 인접한 라우터들에게 전달.
- 각 라우터는 해당 라우팅 정보를 받아 자신의 라우팅 테이블을 작성함.
- 각 라우터는 전체 토폴로지는 알 수 없음.
- 하지만 어느 방향의 라우터로 전달해야하는지는 알고 있음.
- Distance(해당 네트워크까지의 거리)-Vector(해당 네트워크로의 방향)

#### 링크 상태(Link State) 알고리즘

- 각 라우터가 전체 네트워크 토폴로지를 알고 있다. (전체 라우터의 이름과 위치를 알고 있다)
- 각 라우터는 자신의 정보 (인접 라우터의 이름과 거리)를 패킷으로 만들어서 주변에 전달한다.
- 이를 받으면 자신의 라우팅 테이블에 기록한 뒤, 자신의 라우팅 테이블 정보도 패킷에 담아 넘긴다.
- 현재 토폴로지 정보로 목적 라우터까지의 최단 거리 경로를 계산한다.
- 라우팅 테이블에는 각 라우터가 어떤 로컬 네트워크를 가지고 있는지를 같이 저장한다. 이것으로 목적 라우터를 선정할 수 있다.
- Link(각 장비의 Connection 정보)-State(연결 정보)

## 16. 라우터와 스위치의 차이에 대해 설명해주세요. ⭐️

### 라우터(Routing)

- `IP 주소`를 바탕으로 목적지로 전송. (라우팅)
- 네트워크 계층(3계층)에서 작동. 여러 로컬 네트워크를 연결해주는 역할.
- 스위치 보다 느리다. (서브넷 마스크 이용해서 네트워크 ID 확인하는 과정 추가, 외부와 통신하기 위한 여러 기능 추가)

### 스위치(Switch)

- `MAC 주소`를 바탕으로 목적지로 전송. (스위칭)
- 데이터링크 계층(2계층)에서 작동. 한 로컬 네트워크에서 패킷을 전달.
- 일부 스위치는 3계층에서 작동하며 라우팅 기능을 제공하기도 함.

## 17. 세션 기반 인증과 토큰 기반 인증의 차이에 대해 설명하고, 어느 경우에 적합한지 설명해주세요. ⭐️⭐️

### 세션 기반 인증

- 인증/인가를 위해 클라이언트가 서버에 전달하는 데이터 크기가 작음.
- 서버는 해당 데이터를 받고, 메모리나 DB에 저장된 정보와 대조하여 확인함.
- 사용자가 많아지는 경우, 매 인증/인가마다 DB를 조회해야 함. 서버 부하가 커짐.
- 보안이 크리티컬한 경우(비활성화가 용이), 서버 성능이나 확장성이 덜 중요할 경우.

### 토큰 기반 인증

- 세션 기반 인증에 비해 많은 데이터를 전달함.
- 해당 데이터 안에는 인증 정보를 비롯, 발급일, 만료 시간 등의 데이터가 포함되어 있음.
- 사용자가 많아져도 서버에 부하가 덜함. 인증/인가 정보는 해당 인증 데이터에 포함되어 있기 떄문.
- 때문에 세션 기반 인증 보다 Stateless.
- 마이크로 서비스로 이루어진 경우, 사용자가 많아 서버 부하를 고려해야 하는 경우

## 18. CORS에 대해 설명해주세요.

### CORS : Cross-Origin Resource Sharing

### Origin(출처) 이란 ?

URL 상에서 Protocol + Host + Port 을 엮어 말하는 것.

- Same-Origin Policy (동일 출처 정책): 동일한 출처에서만 리소스 공유 가능.
- Cross-Origin Policy (교차 출처 정책): 동일한 출처가 아니더라도 리소스 공유 가능.

### 출처가 다르면 모든 경우에 리소스를 공유할 수 없나?

요청에 따라 다르다.

- `<img>`, `<video>`, `<script>`, `<link>` 태그 등
- 기본적으로 Cross-Origin 정책. 각 태그로 서버의 `.png`, `.jpg`, `.js`, `.css` 등에 접근 가능
- XMLHttpRequest, fetch-api
- 기본적으로 Same-Origin 정책. 서버의 자바스크립트

### CORS 에러가 필요한 이유

기본적으로 `XSS`, `CSRF` 공격을 차단하기 위함.

- `CSRF (Cross-Site Request Forgery)`
- 유저가 악성 사이트에 접속.
- 악성 사이트에서는 유저 모르게 타겟 사이트로 요청을 보냄.
- 타겟 사이트는 악성 사이트로 응답 전달.
- `XSS (Cross-Site Scripting)`
- 타겟 사이트에 스크립트를 심어놓는 방식.
- 유저가 해당 사이트에 접속하면, 공격자가 심어놓은 스크립트를 실행하게 된다.

### 요청 - 응답과 CORS

1. 브라우저에서 서버로 요청을 보낸다. 요청을 보내는 `Origin`을 적어 보낸다.
2. 서버는 응답을 보낸다. 응답에는 `Access-Control-Allow-Origin`에 응답이 허가된 `Origin`을 적어 보낸다.
3. 브라우저는 `Access-Control-Allow-Origin`과 `Origin`을 비교, 이 응답의 유효성을 검증한다. 유효하지 않으면 응답을 버린다.
4. 즉, `CORS`의 검증 주체는 서버가 아닌 브라우저이다.

## 19. 유니캐스트, 브로드캐스트, 멀티캐스트, 애니캐스트에 대해 설명해주세요.

### 유니캐스트

- 1:1 통신. 해당하는 호스트와 직접 데이터를 주고 받으며 통신한다.
- `A클래스`, `B클래스`, `C클래스` 주소 사용

### 브로드캐스트

해당 서브넷의 모두에게 통신

- 일반적으로 마지막 값이 255로 끝나는 IP는 브로드캐스트 용으로 할당되어 있다.
- IP로는 `.255`, MAC으로는 `FF:FF:FF:FF:FF`
- 때문에 서브넷을 잘게 나누면 브로드캐스트 용으로 할당되는 IP 주소가 증가한다.
- `ARP 쿼리`도 브로드캐스트 방식으로 이루어진다.
- 네트워크 효율을 떨어트리는 주요 원인.

### 멀티캐스트

- 브로드캐스트는 서브넷에 참여한 모든 사람들에게 전달한다.
- 서브넷에 N명이 참여중이라면 전달을 N번 해야한다. 비효율적이다.
- 때문에 멀티캐스트는 `정보 요청자들(수신자)`에게만 전달하고, 이를 `1번`에 전달하고자 한다.
- 이 과정에서 네트워크 스위치와 라우터의 도움을 받는다.
- 수신자들은 group에 조인하면 정보를 받을 수 있다.
- 송신자는 유니캐스트의 주소 사용. 목적지는 `D클래스` 주소 사용
- 라우터는 목적지가 있는 여러 방향의 라우터로 패킷을 전달.
- 라우터는 `멀티캐스트 테이블`을 가지고 있다.
- 주기적으로 수신자들에게 패킷을 던져서 아직 가입 중인지 확인한다.

### 애니캐스트

- N개의 목적지 노드 중 가장 가까운 노드로 데이터 전송
- 1개의 목적지만 존재한다면, 일시적인 트래픽 부하에 크게 영향 받을 수 있음.
- N개의 목적지 노드를 설정하고, 요청을 여러 목적지 노드에 분산.
- 네트워크 탄력성, DDOS에 대한 완화

## 20. JWT 토큰에 대해 설명해주세요. ⭐️

- `JWT 토큰`은 Json Web Token 의 약자이다. 유저를 식별하고 인증하기 위해 사용한다.
- `헤더`, `페이로드`, `서명` 세 부분으로 구성된다.
  - `헤더`: 토큰 타입과 암호화에 사용된 알고리즘 정보 등
  - `페이로드`: 정보의 조각들인 `Claim`이 담겨있음. 저장되는 정보에 따라 `공개 Public`, `비공개 Private`, `등록 Registered`로 구분. 토큰 발급자, 발급 시간, 만료 시간, 권한 등의 정보 저장.
  - `서명`: 헤더의 암호화 알고리즘이 적용되는 부분. 서버의 개인키를 이용해 암호화된다. 인코딩 된 헤더와 페이로드 정보가 암호화되어 있다.

### 왜 씀 ?

- 웹 서버가 여러개인 경우 인증 정보가 공유되지 않음. 세션이 별도로 존재하니까.
- 이런 경우에 인증 정보를 공유하기 위해서 사용함
- 물론 JWT만이 유일한 해결책은 아님 (Sticky Session, Clustering 등의 해결 가능)

## 21. Connection timeout 과 Read timeout의 차이에 대해 설명해주세요. ⭐️⭐️

### Connection Timeout

- 연결이 예상 시간보다 오래 걸려서 연결을 하지 못함.
- 일반적으로 서버 장애나 네트워크 오류로 인해 발생.

### Read Timeout

- 연결은 했으나, 서버에서 응답을 받는데 예상보다 오래 시간이 걸려 제대로 응답을 받지 못함.
- 서버 부하, 네트워크 지연 등의 문제로 인해 발생.

### Connection Timeout 발생 시

- 서버나 네트워크 장애 여부 확인.
- 네트워크 환경에 따라 Timeout 값 조정.

## 22. IOCP에 대해 설명해주세요.

### IOCP(Input/Ouptput Completion Port)

- 윈도우 환경에서 사용하는 논-블로킹 프로세스.
- 블로킹 환경에서 I/O시에는 쓰레드의 낭비가 너무 심하다. 논블로킹으로 I/O 작업을 진행한다.
- 하지만 논블로킹에서도 timegap을 줄이기 위해 I/O 작업 완료를 주기적으로 확인해주어야 한다.
- 주기적으로 확인하는 과정에서도 자원이 소모된다.
- 이를 해결하고자 작업이 I/O 작업이 완료된 건은 큐에 적재해놓는다.
- 미리 완료된 I/O 작업들만 다루는 쓰레드풀을 할당해놓는다.
- 해당 쓰레드들은 큐에서 하나씩 뽑아서 작업을 완료한다.

## 23. POLLING은 무엇인지 설명해주세요.

### Polling

주기적으로 상태를 검사해서 일정한 조건을 만족할 때 작업하는 것.
CSMA/CD 방식도 `Polling`을 통해서 `Collision Detection` 한다.

### Long Polling

- `Polling`은 단순하게 주기적으로 상태를 확인하는 것.
- `Long Polling`은 서버의 상태가 변경될 때까지 연결을 유지하고 있다가, 상태가 변경되면 데이터를 받아서 처리하고 다시 연결을 생성한다.
- 보다 Realtime이다.

## 24. 대칭키, 비대칭키 암호화 방식에 대해 설명해주세요.

### 대칭키

- 암호화와 복호화에 사용하는 키가 동일.
- 요청자와 응답자가 같은 키를 공유. 요청자가 암호화하여 전달하면 응답자가 복호화하여 확인.
- 단순한 방식이지만, 키를 공유하는 과정에서 탈취 당하기 쉬움.
- 그렇다면 공유하지 않고 어떻게 데이터를 암호화하여 주고 받을 수 있을까?

### 비대칭키

- 암호화와 복호화에 사용하는 키가 다름.
- 일반적으로 암호화 키를 공개키, 복호화 키를 개인 키로 사용. 공개 키는 공개한다.
- 공개 키로 암호화하여 전달된 데이터를 내가 가진 복호화키(개인 키)로 해독하여 응답함으로써 신원을 증명함. (RSA 알고리즘)
- 복호화키(개인 키)는 항상 나 혼자서만 소유하므로 보안에 안전.
- 하지만 PK(Public Key)가 실제로 응답자의 PK인지 어떻게 확신할 수 있을까?
- 제3자(CA, Certificate Authority)가 필요한 이유. PK의 신뢰성을 확인해주는 인증기관.
- 대칭키 방식에 비해 속도가 느리다. (처리 지연) 많은 데이터를 암호화하는 경우에는 하이브리드 방식(AES 알고리즘) 사용.

## 25. DNS란 무엇인지 설명해주세요.

- 도메인을 ip로 변환해주는 서버.
- ip 주소는 기억하기 어렵다. 때문에 문자열을 활용하여 주소로 사용. 이것이 도메인.
- 하지만 통신하기 위해서는 다시 IP로 변환해야 한다. 이 과정에서 DNS에 질의를 통해 ip를 확인할 수 있다.

#### 작동하는 방식

- 도메인은 계층적인 구조로 이루어져 있다.
- 가장 상위의 도메인(루트 도메인, 도메인에서 확인하기로 맨 뒤의 `.` 이후부터)을 다루는 DNS 서버부터 하위 DNS 서버까지 하위로 오면서 목적지 ip를 찾게 된다.
