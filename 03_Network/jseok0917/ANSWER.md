# 네트워크 예상질문 리스트

- 네트워크를 통한 데이터의 전송과정
    - 데이터를 주고받는 건 프로세스와 프로세스 간
    - 프로세스 -> OS ->  

- 네트워크 프로토콜
    - 

- 네트워크 : 기기들이 리소스를 공유하거나 데이터를 주고받기 위해 유선 혹은 무선으로 연결된 통신체계
- Transport Layer : 데이터를 end-to-end(송신자 - 수신자, 기기간) 로 전송하는 역할

1. TCP와 UDP에 대해 설명하고, TCP와 UDP의 차이에 대해 설명해주세요 ⭐️⭐️⭐️⭐️⭐️

- TCP와 UDP는 모두 TCP/IP 스택 상에서 트랜스포트 레이어에 속한 프로토콜로,
<br>네트워크 상에서 데이터를 전송하는 방식의 일종입니다.
<br>TCP와 UDP의 가장 큰 차이점은 연결지향적이냐 아니냐입니다.
<br>TCP는 송신자와 수신자 간의 연결(커넥션)을 통해 데이터의 유실을 방지하고,
<br>분할되어 전송되는 데이터의 순서를 보장할 수 있습니다.
<br>따라서, 데이터 전송의 신뢰성(reliability)을 보장합니다.
<br>반면에, UDP는 TCP와 같이 데이터 유실 방지와 순서 보장을 위한 연결 메커니즘이 존재하지 않기 때문에,
<br>데이터 전송의 신뢰성이 보장되지 않습니다. 그러나, 연결지향적이지 않기 때문에 
<br>확인응답과 같은 오버헤드가 없어 데이터의 빠른 전송이 가능합니다.


- 추가질문
    - 분명히 UDP를 사용하는 경우가 있다. 그러면 UDP에서는 어떻게 데이터 유실을 방지하고 순서를 보장할까?
        - 어플리케이션 레이어 레벨에서 구현한다.



---

2. TCP에서 데이터의 신뢰성을 보장하기 위한 방법은 어떤 것이 있는지 설명해주세요. ⭐️

- TCP에서 데이터의 신뢰성을 보장하기 위한 방법으로 오류제어와 혼잡제어가 존재합니다.

    1. 오류제어란 ?
        - 오류가 발생할 경우, 오류가 발생한 데이터를 재전송
        - 확인응답(+타이머)을 기준으로 오류를 체크
            - ACK를 받지못했을 때
            - 중복된 ACK를 받을 때
            - 수신측이 NACK를 보냈을 때
        - 오류제어 알고리즘
            - Stop and Wait
            - Go Back N
            - Selective Repeat
        
    2. 혼잡제어란 ?
        - 혼잡 : 네트워크 내에 패킷의 수가 과도하게 증가하는 현상
        - 혼잡제어 : 혼잡 현상을 방지하고 제거하기위한 기능
        - 혼잡제어 알고리즘
            - AIMD(Additive Increase / Multiplicative Decrease)
            - Slow Start
            - Fast Retransmit
            - Fast Recovery


- 추가질문
    - 흐름제어 : 송신 속도 ~= 수신 속도일 때

---

3. 3-way handshaking과 4-way handshaking에 대해 설명해주세요. ⭐️⭐️⭐️

- TCP 프로토콜에서 프로그램 간에 데이터를 전송하기 전에
<br>정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에
<br>세션을 수립하는 과정이 필요합니다.
<br>이때 커넥션을 시작하는 과정으로 진행되는게 3-way handshaking
<br>커넥션이 종료되는 과정으로 진행되는게 4-way handshaking입니다.


- 추가질문
    - 3-way handshaking 과정과 4-way handshaking과정에 대한 설명
    - TIME_WAIT에 대해 설명해주세요
        - Server에서 FIN을 전송하기 전에 전송한 패킷이 Routing 
<br>지연이나 패킷 유실로 인한 재전송 등으로 인해
<br> FIN패킷보다 늦게 도착하는 상황이 발생한다면?


<br>

---

4. 사용자가 URL을 입력한 후 화면이 출력되기까지의 과정을 설명해주세요 ****⭐️⭐️⭐️⭐️⭐️

- 브라우저 주소창에 URL을 입력합니다.
  - 입력한 URL이 캐싱돼있다면(브라우저,OS,라우터,ISP) 바로 해당 주소로 TCP커네션
  - 캐싱돼있지않다면 브라우저가 입력된 도메인의 IP주소를 알아내기 위해 DNS Resolver를 통해
<br>ISP의 DNS서버에 요청하여 입력한 URL의 IP주소를 응답받아 TCP커넥션

- 커넥션 후 클라이언트는 HTTP요청을 보내 해당 페이지에 대한 응답을 받고,
- 브라우저는 이 응답 정보(HTML, CSS, JS, 등등)를 토대로 페이지를 출력





- DNS Resolver의 역할
  - DNS Resolver는 로컬 DNS 캐시에 이전에 방문한 도메인 정보가 있는지 확인합니다. 
  - 만약 캐시에 기록이 있다면, 추가적인 DNS 조회가 필요하지 않습니다.
<br>캐시에 정보가 없는 경우, DNS Resolver는 루트 DNS 서버에서 최상위 도메인(TLD) DNS 서버의 IP 주소 정보를 알아냅니다.

  - DNS Resolver는 최상위 도메인(TLD) DNS 서버에 연결하여 권한 네임 서버(Authoritative Name Server)의 IP 주소를 요청하여 받아냅니다.
  - 최종적으로 DNS Resolver는 권한 네임 서버에서 도메인의 최종 IP 주소를 알아냅니다. 
<br>이렇게 받아 온 IP 주소는 로컬 DNS 캐시에 저장됩니다. 이후로는 같은 요청이 있다면 DNS Resolver에서 바로 응답이 가능합니다.

  - 받아온 최종 IP 주소를 다시 거꾸로 운영체제를 거쳐 브라우저로 전달합니다. 


- URL : 인터넷에서 리소스의 위치를 가리키는 문자열

---

5. HTTP 프로토콜에 대해 설명해주세요 ⭐️⭐️⭐️

<br>Hyper Text Transfer Protocol의 약자로,
<br>인터넷에서 데이터를 주고받기 위해 서버-클라이언트 모델을 기반으로
<br>만들어진 애플리케이션 레이어 프로토콜입니다.
<br>stateless 지향합니다. 즉 서버가
<br>각각의 요청-응답 간의 상태정보를
<br>독립적으로 유지하려는 특성을 갖고 있습니다.
  - 비연결성을 지향하므로 확장성이 뛰어납니다.

- 추가질문

---

6. HTTP와 HTTPS의 차이점에 대해서 설명해주세요. ⭐️⭐️⭐️⭐️⭐️

- HTTP는 텍스트 기반의 프로토콜로 데이터를 암호화하지 않습니다.
- 따라서 보안을 위해 HTTP 프로토콜에 SSL 및 TLS 기술을 결합한
- 프로토콜이 HTTPS입니다.
- HTTPS 웹 사이트는 독립된 인증기관(CA)에서 SSL/TLS 인증서를 획득해야 합니다.

    1. 암호화 방식
        - 사용자 브라우저의 주소 표시줄에 https:// URL 형식을 입력하여 HTTPS 웹 사이트를 방문합니다.
<br>브라우저는 서버의 SSL 인증서를 요청하여 사이트의 신뢰성을 검증하려고 시도합니다.
<br>서버는 퍼블릭 키가 포함된 SSL 인증서를 회신으로 전송합니다.
<br>웹 사이트의 SSL 인증서는 서버 아이덴티티를 증명합니다. 
<br>브라우저에서 인증되면, 브라우저가 퍼블릭 키를 사용하여 비밀 세션 키가 포함된 메시지를 암호화하고 전송합니다.
<br>웹 서버는 개인 키를 사용하여 메시지를 해독하고 세션 키를 검색합니다. 
<br>그런 다음, 세션 키를 암호화하고 브라우저에 승인 메시지를 전송합니다.
<br>브라우저와 웹 서버 모두 동일한 세션 키를 사용하여 메시지를 안전하게 교환하도록 전환합니다.
---

7. HTTP 1.0과 1.1의 차이에 대해 설명하세요. ⭐️⭐️⭐️

- 커넥션 유지(Persistent Connection)
    - 파이프라이닝
- 호스트 헤더(Host Header)
- 강력한 인증절차(Improved Authentication Procedure)

---

8. 쿠키(Cookie)와 세션(Session)의 차이점에 대해 설명해주세요 ⭐️⭐️

- 쿠키와 세션은
- stateless한 HTTP프로토콜의 약점을 보완하기 위해 사용됩니다.
<br>둘의 차이점으로는 저장 위치와 보안, 그리고 라이프사이클입니다.

- 추가질문
    - 캐시와의 차이점

- 출처
    - https://btcd.tistory.com/40

---

9. OSI 7 layer와 각 계층에 대해 아는대로 설명해주세요. ⭐️⭐️⭐️⭐️

- 네트워크 시스템 구성을 위한 범용적이고 개념적인 모델
- 각 계층은 하위계층을 포함

- Application Layer
    - 애플리케이션 목적에 맞는 통신방법 제공
    - HTTP(웹페이지간), DNS(도메인을 IP주소로), SMTP(이메일), FTP(파일업로드/다운로드)
- Presentation Layer
    - 애플리케이션 간의 통신에서 메시지 포맷을 관리
        - 인코딩/디코딩, 암호화/복호화, 압축/압축해제
- Session Layer 
    - 애플리케이션 간의 통신에서 세션을 관리
        - RFC
- Transport Layer
    - 애플리케이션 간의 통신 담당
    - 목적지 애플리케이션으로 데이터 전송
        - TCP, UDP
- Network Layer
    - 호스트 간의 통신 담당(IP주소 기반)
    - 목적지 호스트로 데이터 전송
    - 네트워크 간의 최적경로 결정
- Data Layer
    - 직접 연결된 노드 간의 통신 담당
    - MAC 주소 기반 통신(ARP)
- Physical Layer
    - bits 단위로 데이터 전송

---

10. TCP/IP 프로토콜을 스택 4계층으로 설명해주세요. ⭐️⭐️
    - 인터넷이 발명되면서 함께 개발된 프로토콜 스택으로, IETF에서 관리(RFC에서 정의)
    - 크게보면 네트워크 기능을 직접 사용하는 애플리케이션 레이어와
    - 네트워크 기능을 지원하는데 목적이 있는 트랜스포트 레이어, 인터넷 레이어, 링크 레이어로 나뉩니다.

---

11. HTTP에서 사용되는 Method와 각 용도에 대해서 설명해주세요. ⭐️⭐️⭐️

- GET: 서버로부터 정보를 요청하는데 사용
    - 주로 웹 페이지나 이미지와 같은 정적 리소스를 요청할 때 사용됩니다.
    - 요청한 리소스를 가져와서 응답으로 보냅니다.

- POST: 서버로 데이터를 전송하여 처리하는데 사용
    - 주로 폼 데이터를 서버에 제출하여 데이터를 업데이트하거나 새로운 데이터를 생성할 때 사용됩니다.
    - 요청한 데이터를 서버에게 전송하여 처리하고, 결과를 응답으로 보냅니다.

- PUT: 지정된 리소스를 생성하거나 업데이트하는데 사용
    - 주로 RESTful API에서 사용되며, 클라이언트가 리소스의 상태를 변경할 때 사용됩니다.
    - 요청한 데이터를 지정된 URI에 저장하고, 응답으로 성공 여부를 보냅니다.

- DELETE: 지정된 리소스를 삭제하는데 사용
    - 주로 RESTful API에서 사용되며, 클라이언트가 리소스를 삭제할 때 사용됩니다.
    - 지정된 리소스를 삭제하고, 삭제가 성공했는지에 대한 응답을 보냅니다.

- PATCH: 지정된 리소스의 일부를 수정하는데 사용
    - 주로 PUT과 유사하지만, 전체 리소스를 업데이트하는 대신 일부를 수정할 때 사용됩니다.
    - 일부 데이터를 수정하고, 성공 여부에 대한 응답을 보냅니다.

- HEAD: GET과 유사하지만, 실제 데이터를 요청하지 않고 헤더 정보만 요청
    - 주로 리소스의 메타데이터(크기, 타입 등)를 확인할 때 사용됩니다.
    - 헤더 정보를 응답으로 받아옵니다.

- OPTIONS: 서버에서 지원하는 메서드들을 요청합니다.
    - 주로 CORS(Cross-Origin Resource Sharing)와 관련된 요청에 사용됩니다.
    - 서버에서 지원하는 메서드 목록을 응답으로 받아옵니다.

---

12. GET과 POST의 차이를 설명하세요. ⭐️⭐️⭐️⭐️

- 용도, 데이터 전송방식, 캐싱 여부에서 차이가 존재합니다.
- GET은 데이터를 요청하여 받아올 때, POST는 데이터를 전송하여 처리할 때 사용됩니다.
- GET은 URL의 쿼리문자열을 통해 데이터를 전송하고, POST는 Request Body를 통해 데이터를 전송합니다.
    - 따라서, GET은 데이터가 URL에 노출되어 보안적으로 취약합니다.
- GET은 브라우저에 의해 캐싱될 수 있지만, POST는 캐싱되지 않습니다.


---

13. REST(REST API)에 대해 설명하고 RESTful이란 무엇인지 설명해주세요. ⭐️⭐️

- UI : 유저와 사물(컴퓨터, 기계)간의 소통

- API : Application Programming Interface
    - 프로그램과 프로그램 사이에 각자의 기능을 사용할 수 있도록
    - 서로 통신하는 방법을 정의
    - API의 기능을 어떻게 구현하는지 몰라도 그냥 가져다 사용만하면 된다.
    - 리눅스 API
        - 시스템 관련 API:
            - open(), read(), write(), close(): 파일을 열고 읽고 쓰고 닫는데 사용됩니다.
            - mkdir(), rmdir(), unlink(): 디렉토리를 생성하고 삭제하고 파일을 삭제하는데 사용됩니다.
        - 프로세스 관리 관련 API:
            - fork(), exec(), wait(), exit(): 새로운 프로세스를 생성하고 실행하며, 부모 프로세스가 자식 프로세스의 종료를 기다리고 종료하는데 사용됩니다.
            - kill(): 특정 프로세스에 시그널을 보내는데 사용됩니다.
        - 메모리 관리 관련 API:
            - malloc(), free(): 동적 메모리 할당과 해제에 사용됩니다.
            - mmap(), munmap(): 파일이나 디바이스를 메모리에 매핑하고 매핑을 해제하는데 사용됩니다.
        - 장치 관리 관련 API:
            - open(), ioctl(), close(): 장치 파일을 열고 제어하고 닫는데 사용됩니다.
            - read(), write(): 장치로부터 데이터를 읽고 쓰는데 사용됩니다.
        - 네트워킹 관련 API:
            - socket(), bind(), listen(), accept(), connect(): 소켓을 생성하고 연결하고 통신하는데 사용됩니다.

- REST : Representational State Transfer의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것
    - REST API : 이름 자체로 기능을 추론가능하도록, REST 스타일로 만든 API 형식
    1. HTTP

- URI와 URL의 차이점
    - URL(Uniform Resource Locator) : 인터넷 상 자원의 위치
    - URI(Uniform Resource Identifier) : 인터넷 상의 자원을 식별하기 위한 문자열의 구성


- REST 구성 요소
    1. 자원 : HTTP URI
    2. 자원에 대한 행위 : HTTP Method
    3. 자원에 대한 행위의 내용 : HTTP Message Pay Load

- REST의 특징
    1. 서버 - 클라이언트 구조
    2. Stateless
    3. Cacheable
    4. Layered System
    5. Uniform Interface
    6. Self-Descriptiveness

- 장점 
    1. HTTP 프로토콜의 인프라를 그대로 사용하여 REST API 사용을 위한 별도의 인프라를 구축할 필요없음
    2. HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해준다(?)
    3. HTTP 표준 프로토콜을 따르는 모든 플랫폼에서 사용가능
    4. Hypermedia API의 기본을 충실히 지키면서 범용성 보장
    5. REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악가능
    6. 여러가지 서비스 디자인에서 생길 수 있는 문제를 최소화
    7. 서버와 클라이언트의 역할을 명확하게 분리

- 단점
    1. 표준이 존재하지 않아 정의가 필요
    2. HTTP Mehtod 형태가 제한적이다
    3. 브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 정보의 값을 처리해야하므로 전문성이 요구된다.
    4. 구형 브라우저에서 호환이 되지 않아 지원해주지 못하는 동작이 많다.(익스플로러)

- RESTful : REST API의 설계 규칙을 올바르게 지킨 시스템





- ref by https://khj93.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-REST-API%EB%9E%80-REST-RESTful%EC%9D%B4%EB%9E%80
- ref by https://dev-coco.tistory.com/97

---

14. 공인(public) IP와 사설(private) IP의 차이에 대해 설명해주세요. ⭐️⭐️⭐️

- 공인 IP
    - 인터넷 사용자의 로컬 네트워크 식별을 위해 ISP가 제공하는 IP 주소
    - 외부적으로 공개돼있고, 식별자 역할을 하므로 전세계적으로 유일한 IP주소를 가짐
    - 회부 접근이 가능

- 사설 IP
    - 일반 가정이나 회사 내에 할당된 네트워크 IP
    - IPv4의 주소부족으로 인해 서브넷팅된 IP
    - 라우터에 의해 로컬 네트워크 상의 PC나 장치에 할당

- 차이점 : 공인IP vs 사설IP
    - 할당주체 : ISP / 라우터(공유기)
    - 할당 대상 : 개인 또는 회사의 서버(라우터) / 개인 또는 회사의 기기
    - 고유성 : 인터넷 상에서 유일한 주소 / 하나의 네트워크 ㅏㄴ에서 유일
    - 공개 여부 : 내외부 접근 가능 / 외부 접근 불가능

- 고정 IP와 유동 IP
    - 고정 IP : 장비에 고정적으로 부여된 IP
    - 유동 IP : 장비에 고정적으로 IP를 부여하지 않고, 사용 시 남아있는 IP 중에서 할당
    - 예시 : 
        - 우리가 집에서 사용하는 인터넷 서비스는, 그 서비스를 제공하는 ISP가 공인 IP를 유동 IP로 부여
        - 공유기 내부에서는 사설IP를 유동 IP로 부여

- ref by https://velog.io/@hidaehyunlee/%EA%B3%B5%EC%9D%B8Public-%EC%82%AC%EC%84%A4Private-IP%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90


---

15. 라우팅 알고리즘에 대해서 설명해주세요

- 네트워크에서 데이터를 어떻게 전달할지 결정하는 알고리즘으로, 여러 경로 중 최적의 경로를 선택하여 데이터를 전송
- 출발점(v)과 목적지점(z)

1. Link State 라우팅 알고리즘 : 전체 네트워크 환경의 정보를 안다는 가정 하에서 사용할 수 있는 알고리즘
    - 다익스트라 알고리즘

2. Distance Vector 라우팅 알고리즘 : 특정 라우터와 연결된 이웃 라우터의 정보만을 가지고 판단하는 알고리즘
    - 벨만-포드 알고리즘

- ref by https://ddongwon.tistory.com/95

---

16. 라우터와 스위치의 차이에 대해 설명해주세요. ⭐️

- 라우터 : 서로 다른 네트워크의 다양한 스위치를 상호 연결하여 더 넓은 네트워크를 형성하는데 사용
    - 한 네트워크에서 다른 네트워크로 패킷을 라우팅 하는 기능
    - 네트워크 간의 통신을 관리하고 데이터를 전송
    - 네트워크 간의 통신을 담당(두 개 이상의 개별 네트워크 간의 연결)

- 스위치 : 네트워크를 형성하는 다양한 장치 간의 상호 연결을 형성하는 장치
    - 허브의 효율적인 버전
    - 네트워크의 모든 장치를 연결하는 중앙 상호 연결 장치 역할
    - 네트워크 내부에서 데이터를 전송(단일 네트워크에서 여러 장치로 데이터를 전송하는 역할)


---

17. 세션 기반 인증과 토큰 기반 인증의 차이에 대해 설명하고, 어느 경우에 적합한지 설명해주세요. ⭐️⭐️

- 세션 기반 인증
    - 인증정보(서버) & 세션식별자(클라이언트에게 쿠키)
    - 세션 식별자만 관리하면 되므로 보안이 용이
    - 세션 유효기간 서버측에서 유동적으로 관리가능
    - 6바이트

- 토큰 기반 인증
    - 인증정보(쿠키) & 유효성검사(서버)
    - 클라이언트에게 액세스 토큰을 제공, 쿠키로 로컬스토리지나 세션 스토리지에 저장
    - 더 많은 트래픽 사용(JWT 토큰 : 최소 304바이트)
    - 분산환경(확장성 문제)


---

18. CORS에 대해 설명해주세요.

- CORS(Cross-Origin Resource Sharing)
    - 웹 어플리케이션이 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 메커니즘
    - 보안 상의 이유로 브라우저는 원래 Same-Origin Policy로 원래 다른 출처의 리소스에 접근을 제한
    - 서버측에서 CORS 정책을 구성하고 설정(클라이언트 측에서는 불간)

- CSRF(Cross-Site Request Forgery) 공격
    1. 사용자가 인증된 상태로 웹사이트 A에 로그인합니다.
        - 사용자는 웹사이트 A에 로그인하여 세션을 확립합니다.
    2. 악의적인 웹사이트 B를 방문합니다.
        - 사용자가 악의적인 웹사이트 B를 방문합니다.
    3. 웹사이트 B에서는 사용자의 브라우저를 통해 웹사이트 A에 인증된 요청을 보냅니다.
        - 웹사이트 B는 사용자의 브라우저를 통해 웹사이트 A의 인증된 요청을 생성합니다. 이를 위해 JavaScript 등을 사용할 수 있습니다.
        - 이 때, 악의적인 요청은 웹사이트 A에 대해 유효한 인증된 세션을 가지고 있으므로 웹사이트 A는 해당 요청을 사용자의 인증된 권한으로 처리합니다.
    4. 웹사이트 A에서는 악의적인 요청을 처리합니다.
        - 웹사이트 A는 사용자의 브라우저를 통해 받은 인증된 요청을 처리합니다. 
        - 이 때, 서버는 해당 요청이 웹사이트 B에서 보낸 것임을 인식하지 못하고 사용자의 인증된 세션을 통해 처리하므로, 악의적인 동작이 실행됩니다.




- 외부 도메인 
    - 현재 사용자가 접속한 도메인과 다른 도메인, 웹 브라우저는 현재 사용자가 접속한 도메인을 "출처(origin)"로 인식
    - 웹 브라우저에서의 "출처"는 프로토콜(http, https), 호스트(도메인), 포트로 정의됩니다. 따라서 동일한 프로토콜, 호스트, 포트를 가진 리소스들은 동일한 출처로 간주
    - http://example.com과 https://example.com은 서로 다른 출처로 간주, http://example.com과 http://subdomain.example.com도 서로 다른 출처
    - CORS는 현재 사용자가 접속한 도메인과 다른 출처로부터의 요청을 제어하는데 사용됩니다. 출처가 다른 경우에는 추가적인 보안 검사를 수행하거나 요청을 거부할 수 있음
    - 다른 출처인지 같은 출처인지는 브라우저에서 확인
    - 요청을 보낼 때 브라우저는 헤더에 출처 정보도 실어서 보낸다.
    - 다른 웹사이트가 Origin 헤더 위조도 가능함


- CSRF 공격 코드

```javascript
fetch('https://bank.example.com/transfer', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    // 여기에 필요한 인증 토큰 등의 헤더를 추가할 수 있습니다.
  },
  body: JSON.stringify({ recipient: 'attacker', amount: '1000000' })
})
.then(response => {
  if (response.ok) {
    alert('송금이 완료되었습니다.');
  } else {
    alert('송금에 실패했습니다.');
  }
})
.catch(error => {
  console.error('송금 중 오류가 발생했습니다.', error);
});

```

- 서버 측에서는 클라이언트가 전송한 요청의 Origin 헤더를 신뢰해서는 안됨
    - CORS 요청 검증: 
        - 서버는 클라이언트로부터 받은 요청에 포함된 Origin 헤더를 사용하여 요청의 출처를 식별합니다. 
        - 그러나 이 출처 정보만을 신뢰하여는 안 됩니다. 대신, 서버는 이를 통해 요청을 수락하거나 거부하는데 사용될 수 있습니다.

    - 추가적인 인증 검사: 
        - 서버는 CORS 요청을 받은 후에도 클라이언트의 인증 정보를 추가적으로 검증할 수 있습니다. 
        - 예를 들어, 사용자의 세션 또는 토큰을 사용하여 클라이언트의 신원을 확인하고, 이를 통해 요청을 처리할 수 있습니다.

    - CSRF 방어 메커니즘: 
        - 서버는 CSRF 공격을 방어하기 위해 CSRF 토큰을 사용하고, 클라이언트가 이를 포함시켜 요청을 보내도록 요구할 수 있습니다. 
        - 이를 통해 서버는 요청의 유효성을 검증하고, 실제로 사용자가 원하는 요청인지를 확인할 수 있습니다.

    - 정규화된 요청 검증: 
        - 서버는 정규화된 요청 검증 절차를 사용하여 입력 데이터를 검증하고, 악성 요청을 필터링할 수 있습니다. 
        - 이를 통해 서버는 악의적인 요청을 식별하고 거부할 수 있습니다.




---

19. 유니캐스트, 브로드캐스트, 멀티캐스트, 애니캐스트에 대해 설명해주세요.

- 유니캐스트(Unicast): 
    - 단일 목적지에 데이터를 전송하는 통신 방식
    - 한 대의 송신자가 한 대의 수신자에게 데이터를 보내는 방식
- 브로드캐스트(Broadcast): 
    - 네트워크 상의 모든 장치에 데이터를 전송하는 통신 방식
    - 한 대의 송신자가 네트워크 상의 모든 장치에 데이터를 보내는 방식

- 멀티캐스트(Multicast): 
    - 특정 그룹에 속한 여러 대의 수신자에게 데이터를 전송하는 통신 방식
    - 송신자는 데이터를 특정 그룹의 멀티캐스트 주소로 전송하면 해당 그룹에 속한 여러 대의 수신자가 데이터를 수신

- 애니캐스트(Anycast): 
    - 여러 대의 목적지 중 가장 가까운 목적지에 데이터를 전송하는 통신 방식
    - 여러 대의 수신자 중에서 가장 가까운 네트워크 장비에 데이터를 전송

---

20. JWT 토큰에 대해 설명해주세요. ⭐️

JWT(JSON Web Token) : 웹 표준으로서 두 개체 간에 JSON 객체를 안전하게 전송하기 위한 간결하고 독립적인 방법을 제공하는 인증 토큰
    - JWT는 클라이언트와 서버 간의 인증을 위해 사용되며, 토큰 안에는 클라이언트에 대한 정보와 해당 토큰의 유효성을 검증하기 위한 서명이 포함
    - JWT는 자가 수용적(self-contained)이기 때문에 서버의 데이터베이스에 토큰을 저장할 필요가 없으며, 분산 환경에서 효율적으로 작동
---

21. Connection timeout 과 Read timeout의 차이에 대해 설명해주세요. ⭐️⭐️

- Connection timeout: 
    - 클라이언트가 서버에 연결을 요청했을 때, 서버가 응답을 보내지 않고 일정 시간이 경과하면 연결이 실패한 것으로 간주되는 시간
    - 즉, 서버와의 연결을 수립하는데 소요되는 최대 시간

- Read timeout: 
    - 클라이언트가 서버에 데이터를 요청했을 때, 서버가 일정 시간 동안 응답을 보내지 않으면 읽기 작업이 실패한 것으로 간주되는 시간
    - 즉, 서버로부터 데이터를 읽어오는데 소요되는 최대 시간

---

22. IOCP에 대해 설명해주세요.

IOCP(Input/Output Completion Port) : Microsoft Windows 플랫폼에서 비동기 입출력(I/O) 작업을 지원하기 위한 메커니즘, 주로 네트워크 서버 프로그래밍에서 사용

- 비동기 입출력: 
    - 일반적으로 I/O 작업은 동기적으로 수행되어 해당 작업이 완료될 때까지 대기합니다. 
    - 하지만 비동기 입출력은 요청한 작업이 완료될 때까지 대기하지 않고 다른 작업을 수행할 수 있도록 합니다.

- 입출력 완료 포트: 
    - IOCP는 완료된 I/O 작업을 대기하고 있는 입출력 완료 포트를 사용하여 비동기적으로 입출력 작업을 관리합니다. 
    - 완료된 작업은 이벤트 큐에 저장되어 후속 처리를 위해 대기하게 됩니다.

- IOCP의 장점
    - IOCP를 사용하면 하나의 스레드가 여러 개의 입출력 작업을 동시에 처리할 수 있으며, 
    - 이는 서버의 확장성과 성능을 향상시킵니다. 
    - 또한, Windows 운영체제에서 제공하는 IOCP API를 사용하여 비동기 네트워크 프로그래밍을 간단하게 구현할 수 있습니다.

---

23. POLLING은 무엇인지 설명해주세요.

- 주기적으로 데이터나 이벤트를 확인하고 처리하는 기술

- 사용예시
    - 하드웨어 제어
    - 네트워크 통신
        - 데이터 파이프라인에서 소스DB나 카프카에 저장된 메시지를 캡처링할 때
    - 모니터링


---

24. 대칭키, 비대칭키 암호화 방식에 대해 설명해주세요. 

- 대칭키 암호화(Symmetric-key Encryption): 
    - 암호화하고 복호화에 동일한 키를 사용
        - 연산 속도가 빠르지만 키를 교환해야하는 문제가 발생
    - 키를 교환할 때 안전하게 교환해야함, 사용자가 많아지면 많아질 수록 관리해야하는 키가 방대해짐
        - 키의 사전 공유, 키 배포 센터 사용, Diffie-Hellman 키 교환, 공개키 암호화 방식 
    - 대표적으로 DES(Data Encryption Standard), AES(Advanced Encryption Standard)

- 비대칭키 암호화(Asymmetric-key Encryption): 
    - A : 공개키, 개인키, B : 공개키, 개인키
        - 공개키로 암호화, 개인키로 복호화
        - A -> B로 데이터를 보낼 때, A는 B의 공개키로 데이터를 암호화하여 전송
        - B는 자신의 개인키로 A가 보낸 데이터를 복호화

    - 공개키와 개인키를 사용하여 데이터를 암호화하고 복호화하는 방식
    - 공개키는 누구나 알 수 있음, 개인키는 소유자만 알고 있음
    - 대표적으로 RSA
        - 키를 교환할 필요가 없지만, 대신 평문의 길이가 길어지면 길어질수록 연산속도가 매우 느려진다
        - 따라서 대칭키를 공개키(배디칭키) 방식으로 교환하고, 이렇게 공유된 대칭키로 데이터를 주고받는다(대표적인 예 : HTTPS)


- 암호화에 필수적인 기능
    - 기밀성(Confidentiality): 인가되지 않은 자는 정보를 확인하지 못하도록 하며, 정보가 유출되더라도 평문으로 해독할 수 없고 변조 또는 위조하지 못하도록 기밀을 유지한다.
    - 무결성(Integrity): 인가 되지 않은 자로 부터 위조 또는 변조가 발생하지 않았는지 확인
    - 인증(Authentication): 수신 받은 메시지가 송신자 본인이라는 것을 확인하고 증명한다.
    - 부인 방지(Non-repudiation): 메시지를 보낸 사람이 보낸 사실을 부인하거나, 받은 사람이 받은 사실을 부인할 경우 증명하는 기술을 말한다.


---

25. DNS란 무엇인지 설명해주세요.

- Domain Name System의 약자로, 도메인 이름을 IP주소로 변환하여 주는 시스템입니다.
<br>기억하기 어려운 숫자로 된 IP주소 대신에
<br>Domain Name, 즉 문자열을 통하여 웹사이트에 접속할 수 있도록 해줍니다.
<br>한마디로 인터넷의 주소록이라 할 수 있습니다.

- 분산 DNS 서버 일관성 유지 방법
    - DNS 캐시
    - DNS 동기화(마스터 DNS 서버 - 슬레이브 DNS 서버)
    - DNS 트랜잭션 ID
    - DNS 프로토콜의 일관성 유지
